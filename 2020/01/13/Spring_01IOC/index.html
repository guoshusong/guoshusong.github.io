<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IOC、循环依赖的解决 | gssplus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="gss's Blog" />
  
  <meta name="description" content="IOC简介及原理、Bean的生命周期、循环依赖的解决">
<meta property="og:type" content="article">
<meta property="og:title" content="IOC、循环依赖的解决">
<meta property="og:url" content="https://guoshusong.github.io/2020/01/13/Spring_01IOC/index.html">
<meta property="og:site_name" content="gssplus&#39;s Blog">
<meta property="og:description" content="IOC简介及原理、Bean的生命周期、循环依赖的解决">
<meta property="og:image" content="https://i.loli.net/2020/01/13/igBc9Xj5VDeNH7k.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/7hgnrLPD8CTcqAI.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/2Ont5HQ4ILlAWEw.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/2EdLT6anIbpACNt.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/BEIwzsRPotguCaL.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/5gdHmJTbV723QEt.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/pIzU3RbtVeqWlZ7.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/Y4ksl2ir37j9Umn.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aa2ee86235e4a95b2c3169d6f2050f0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c3129d1e264fd5abf64fb40643f8e0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://i.loli.net/2020/01/13/pwAdGtVaRcoCMuB.png">
<meta property="og:image" content="https://i.loli.net/2020/01/13/7mUZQsxcp9WGabD.png">
<meta property="article:published_time" content="2020-01-13T08:05:57.000Z">
<meta property="article:modified_time" content="2020-10-06T03:32:58.171Z">
<meta property="article:author" content="GuoShuSong">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/01/13/igBc9Xj5VDeNH7k.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Hello,Here is gssplus!</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Hello,Here is gssplus!
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        我见过春日夏风，秋月冬雪，也曾踏遍南水北山，东麓西岭，可这四季春秋，苍山央水，都不及你瞅我展眉一笑
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="//guoshusong.github.io/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/guoshusong">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Spring_01IOC" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      IOC、循环依赖的解决
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/SpringBoot/">SpringBoot</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-01-13
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="IOC简介及原理、Bean的生命周期、循环依赖的解决"><a href="#IOC简介及原理、Bean的生命周期、循环依赖的解决" class="headerlink" title="IOC简介及原理、Bean的生命周期、循环依赖的解决"></a>IOC简介及原理、Bean的生命周期、循环依赖的解决</h2><a id="more"></a>

<h3 id="IOC简介"><a href="#IOC简介" class="headerlink" title="IOC简介"></a>IOC简介</h3><p>IoC(Inversion of Control)控制反转，包含了两个方面</p>
<ul>
<li><p>控制(当前对象对内部成员的控制权)</p>
</li>
<li><p>反转(这种控制权不由当前对象管理了，由其他(类,第三方容器)来管理)</p>
</li>
</ul>
<p>IOC不够开门见山，于是Martin Fowler提出了DI(dependency injection)来替代IoC，即让调用类对某一接口实现类的依赖关系由第三方(容器或协作类)注入，以移除调用类对某一接口实现类的依赖。</p>
<p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去.</p>
<p>IoC(思想，设计模式)主要的实现方式有两种：依赖查找，依赖注入。</p>
<p>依赖注入是一种更可取的方式(实现的方式)</p>
<p>所谓的IOC容器就是一个大工厂(第三方容器)</p>
<p>使用IOC的好处</p>
<ul>
<li><p>不用自己组装，拿来就用。</p>
</li>
<li><p>享受单例的好处，效率高，不浪费空间。</p>
</li>
<li><p>便于单元测试，方便切换mock组件。</p>
</li>
<li><p>便于进行AOP操作，对于使用者是透明的。</p>
</li>
<li><p>统一配置，便于修改.</p>
</li>
</ul>
<h3 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h3><p>IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系。</p>
<p>原理就是通过Java的反射技术来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</p>
<p>再通过配置文件(xml)或者注解来描述类与类之间的关系</p>
<p>我们就可以通过这些配置信息和反射技术来构建出对应的对象和依赖关系了！</p>
<p>Spring IOC容器实现对象的创建和依赖:</p>
<p><img src="https://i.loli.net/2020/01/13/igBc9Xj5VDeNH7k.png" alt="IOC0.PNG"></p>
<p>Bean缓存池：HashMap实现</p>
<ul>
<li><p>根据Bean配置信息在容器内部创建Bean定义注册表</p>
</li>
<li><p>根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</p>
</li>
<li><p>将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用</p>
</li>
</ul>
<p>Spring容器(Bean工厂)可简单分成两种：</p>
<ul>
<li>BeanFactory</li>
</ul>
<p>这是最基础、面向Spring的</p>
<ul>
<li>ApplicationContext</li>
</ul>
<p>这是在BeanFactory基础之上，面向使用Spring框架的开发者。提供了一系列的功能！</p>
<p>几乎所有的应用场合都是使用ApplicationContext</p>
<h4 id="BeanFactory的继承体系"><a href="#BeanFactory的继承体系" class="headerlink" title="BeanFactory的继承体系"></a>BeanFactory的继承体系</h4><p><img src="https://i.loli.net/2020/01/13/7hgnrLPD8CTcqAI.png" alt="BeanFactory.PNG"></p>
<h4 id="ApplicationContext的继承体系："><a href="#ApplicationContext的继承体系：" class="headerlink" title="ApplicationContext的继承体系："></a>ApplicationContext的继承体系：</h4><p><img src="https://i.loli.net/2020/01/13/2Ont5HQ4ILlAWEw.png" alt="ApplicationContext.PNG"></p>
<p>其中在ApplicationContext子类中又有一个比较重要的：WebApplicationContext</p>
<p><img src="https://i.loli.net/2020/01/13/2EdLT6anIbpACNt.png" alt="webApplicationContext.PNG"></p>
<p>web应用与Spring融合</p>
<p><img src="https://i.loli.net/2020/01/13/BEIwzsRPotguCaL.png" alt="web.PNG"></p>
<h4 id="BeanFactory生命周期"><a href="#BeanFactory生命周期" class="headerlink" title="BeanFactory生命周期"></a>BeanFactory生命周期</h4><p><img src="https://i.loli.net/2020/01/13/5gdHmJTbV723QEt.png" alt="BeanFactory生命周期.PNG"></p>
<h4 id="ApplicationContext生命周期"><a href="#ApplicationContext生命周期" class="headerlink" title="ApplicationContext生命周期"></a>ApplicationContext生命周期</h4><p><img src="https://i.loli.net/2020/01/13/pIzU3RbtVeqWlZ7.png" alt="ApplicationContext生命周期.PNG"></p>
<p>初始化的过程都是比较长，我们可以分类来对其进行解析：</p>
<ul>
<li><p>Bean自身的方法：如调用 Bean 构造函数实例化 Bean，调用 Setter 设置 Bean 的属性值以及通过标签设置init-method 和 destroy-method 所指定的方法；</p>
</li>
<li><p>Bean级生命周期接口方法：如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，这些接口方法由 Bean 类直接实现；</p>
</li>
<li><p>容器级生命周期接口方法：在上图中带“★” 的步骤是由 InstantiationAwareBean PostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“ 后处理器” 。 后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为Spring容器预先识别。当Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣Bean 进行加工处理</p>
</li>
</ul>
<h4 id="ApplicationContext和BeanFactory不同之处在于："><a href="#ApplicationContext和BeanFactory不同之处在于：" class="headerlink" title="ApplicationContext和BeanFactory不同之处在于："></a>ApplicationContext和BeanFactory不同之处在于：</h4><p>ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor后置器，并自动将它们注册到应用上下文中。而BeanFactory需要在代码中通过手工调用addBeanPostProcessor()方法进行注册.BeanFactory只是一个用于生产bean的工厂，它不具备读取和解析配置文件的能力，不具备生产图纸也就是Bean定义的能力</p>
<p>ApplicationContext在初始化应用上下文的时候就实例化所有单实例的Bean。而BeanFactory在初始化容器的时候并未实例化Bean，直到第一次访问某个Bean时才实例化目标Bean。</p>
<p><a href="https://elsef.com/2019/11/10/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" target="_blank" rel="noopener">关于Bean的生命周期，详细内容可以看这一篇博客</a></p>
<h4 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h4><p><img src="https://i.loli.net/2020/01/13/Y4ksl2ir37j9Umn.png" alt="Bean的初始化过程"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；</p>
</li>
<li><p>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy进行Bean实例化的工作；使用BeanWrapper完成Bean属性的设置工作；</p>
</li>
<li><p>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。</p>
</li>
</ul>
<h3 id="IOC容器装配Bean"><a href="#IOC容器装配Bean" class="headerlink" title="IOC容器装配Bean"></a>IOC容器装配Bean</h3><h4 id="装配方式"><a href="#装配方式" class="headerlink" title="装配方式"></a>装配方式</h4><p>Spring4.x开始IOC容器装配Bean有4种方式：</p>
<ul>
<li><p>XML配置</p>
</li>
<li><p>注解</p>
</li>
<li><p>JavaConfig</p>
</li>
<li><p>基于Groovy DSL配置(这种很少见)</p>
</li>
</ul>
<p>总的来说：我们以XML配置+注解来装配Bean得多，其中注解这种方式占大部分。</p>
<h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>依赖注入的方式有3种方式：</p>
<ul>
<li><p>属性注入–&gt;通过setter()方法注入</p>
</li>
<li><p>构造函数注入</p>
</li>
<li><p>工厂方法注入</p>
</li>
</ul>
<p>总的来说使用属性注入是比较灵活和方便的.</p>
<h4 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h4><ul>
<li><p>依赖–&gt;挺少用的(使用depends-on就是依赖关系了–&gt;前置依赖【依赖的Bean需要初始化之后，当前Bean才会初始化】)</p>
</li>
<li><p>继承–&gt;可能会用到(指定abstract和parent来实现继承关系)</p>
</li>
<li><p>引用–&gt;最常见(使用ref就是引用关系了)</p>
</li>
</ul>
<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><ul>
<li><p>单例Singleton</p>
</li>
<li><p>多例prototype</p>
</li>
<li><p>与Web应用环境相关的Bean作用域:reqeust、session</p>
</li>
</ul>
<p>使用到了Web应用环境相关的Bean作用域的话，是需要我们手动配置代理的。</p>
<p>原因也很简单：因为我们默认的Bean是单例的，为了适配Web应用环境相关的Bean作用域—&gt;每个request都需要一个对象，此时我们返回一个代理对象出去就可以完成我们的需求了。</p>
<p>将Bean配置单例的时候还有一个问题：</p>
<ul>
<li><p>如果我们的Bean配置的是单例，而Bean对象里边的成员对象我们希望是多例的话。那怎么办呢？？</p>
</li>
<li><p>默认的情况下我们的Bean单例，返回的成员对象也默认是单例的(因为对象就只有那么一个)！</p>
</li>
</ul>
<p>此时我们需要用到了lookup方法注入</p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖就是依赖关系形成环，比如最简单的循环依赖：A对象依赖B，B对象依赖A</p>
<h4 id="获取Bean流程"><a href="#获取Bean流程" class="headerlink" title="获取Bean流程"></a>获取Bean流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aa2ee86235e4a95b2c3169d6f2050f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ol>
<li><p>流程从 getBean 方法开始，getBean 是个空壳方法，所有逻辑直接到 doGetBean 方法中</p>
</li>
<li><p>transformedBeanName 将 name 转换为真正的 beanName（name 可能是 FactoryBean 以 &amp; 字符开头或者有别名的情况，所以需要转化下）</p>
</li>
<li><p>然后通过 getSingleton(beanName) 方法尝试从缓存中查找是不是有该实例 sharedInstance（单例在 Spring 的同一容器只会被创建一次，后续再获取 bean，就直接从缓存获取即可）</p>
</li>
<li><p>如果有的话，sharedInstance 可能是完全实例化好的 bean，也可能是一个原始的 bean，所以再经 getObjectForBeanInstance 处理即可返回</p>
</li>
<li><p>当然 sharedInstance 也可能是 null，这时候就会执行创建 bean 的逻辑，将结果返回</p>
</li>
</ol>
<h4 id="属性注入与循环依赖"><a href="#属性注入与循环依赖" class="headerlink" title="属性注入与循环依赖"></a>属性注入与循环依赖</h4><ul>
<li><p>如果是构造器注入，如果循环依赖对象没法构建，因为还未实例化</p>
</li>
<li><p>如果是属性注入但是作用域是prototype，spring不会缓存其对象实例，也不能处理循环依赖的情况</p>
</li>
<li><p>如果是属性注入singleton的，其bean的实例化过程与属性注入过程是分开的，并且spring提供了三个map（就是大家说三级缓存）来实现。</p>
</li>
</ul>
<h4 id="spring属性注入处理循环依赖的方式"><a href="#spring属性注入处理循环依赖的方式" class="headerlink" title="spring属性注入处理循环依赖的方式"></a>spring属性注入处理循环依赖的方式</h4><p>通过以下xml方式配置一个循环依赖的示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">class</span>=<span class="string">"com.example.leetcode.spring.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parent"</span> <span class="attr">ref</span>=<span class="string">"person2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"tom"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.example.leetcode.spring.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"parent"</span> <span class="attr">ref</span>=<span class="string">"person1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"jack"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="spring循环依赖处理几个关键位置："><a href="#spring循环依赖处理几个关键位置：" class="headerlink" title="spring循环依赖处理几个关键位置："></a>spring循环依赖处理几个关键位置：</h4><ol>
<li>获取bean对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里会检查单例bean是否已经在注册表，并返回。</span></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DefaultSingletonBeanRegistry（单例对象注册表）的几个关键属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存储已经创建好的单例对象</span></span><br><span class="line"><span class="comment">//完成初始化的单例对象的 cache，这里的 bean 经历过 实例化-&gt;属性填充-&gt;初始化 以及各种后置处理（一级缓存）</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存储单例beanname到ObjectFactory的映射</span></span><br><span class="line"><span class="comment">// 在 bean 实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring 会将实例化后的 bean 提前曝光，也就是把该 bean 转换成 beanFactory 并加入到 singletonFactories（三级缓存）</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来提前存储还未初始化好的单例对象</span></span><br><span class="line"><span class="comment">// 存放原始的 bean 对象（完成实例化但是尚未填充属性和初始化），仅仅能作为指针提前曝光，被其他 bean 所引用，用于解决循环依赖的 （二级缓存）</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>DefaultSingletonBeanRegistry.getSingleton()的实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 singletonObjects 获取实例，singletonObjects 中的实例都是准备好的 bean 实例，可以直接使用</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//isSingletonCurrentlyInCreation() 判断当前单例bean是否正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 一级缓存没有，就去二级缓存找</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 二级缓存也没有，就去三级缓存找</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 三级缓存有的话，就把他移动到二级缓存,.getObject() 后续会讲到</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>AbstractAutowireCapableBeanFactory.doCreateBean创建对象与注入属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 检查是否提前将单例bean存入缓存</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">        isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里将beanname与工厂映射放入缓存注册表中(也就是上面的singletonFactories)</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注入依赖属性</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    ...</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="假设我们从beanfactory获取person1对象，-循环依赖处理流程如下："><a href="#假设我们从beanfactory获取person1对象，-循环依赖处理流程如下：" class="headerlink" title="假设我们从beanfactory获取person1对象， 循环依赖处理流程如下："></a>假设我们从beanfactory获取person1对象， 循环依赖处理流程如下：</h4><ol>
<li><p>通过AbstractBeanFactory.doGetBean(“persion1”)获取对象</p>
</li>
<li><p>因为一开始通过DefaultSingletonBeanRegistry.getSingleton()什么都没有，进入AbstractAutowireCapableBeanFactory.doCreateBean()进行创建</p>
</li>
<li><p>AutowireCapableBeanFactory.doCreateBean()里面执行完创建逻辑，因为是singleton将beanname与工厂的映射加入到addSingletonFactory()到缓存</p>
</li>
<li><p>开始处理person1对象的属性依赖populateBean()</p>
</li>
<li><p>当发现person1的parent属性是一个引用时，通过beanfactory.getBean(“person2”)获取依赖对象（org.springframework.beans.factory.support.BeanDefinitionValueResolver#resolveReference）</p>
</li>
<li><p>此时进入person2的创建流程， person2也没有缓存，开始实例化并加入到addSingletonFactory()到缓存</p>
</li>
<li><p>person2在通过populateBean()注入属性依赖发现依赖person1, 此时通过beanfactory.getBean(“person1”)获取依赖对象</p>
</li>
<li><p>此时AbstractBeanFactory.doGetBean(“persion1”)获取对象执行到getSingleton(“person1”)进行以下判断：</p>
</li>
</ol>
<p>&nsp; 从singletonObjects.get(beanName)获取到null</p>
<p>&nsp; 进入if条件，对singletonObjects同步</p>
<p>&nsp; 从earlySingletonObjects.get(beanName);获取也为null</p>
<p>&nsp; 进入内层if，通过singletonFactories.get(beanName);获取到最开始bean实例化之后的beanname与工厂缓存信息</p>
<p>&nsp; 获取到仅实例化完成的bean，并earlySingletonObjects.put(beanName, singletonObject);</p>
<p>&nsp; 然后删除singletonFactories.remove(beanName);</p>
<ol start="9">
<li><p>此时从getSingleton(“person1”)返回了一个仅实例化尚未注入的bean引用</p>
</li>
<li><p>person2在第7步获取到person1仅实例化未注入的对象引用。</p>
</li>
<li><p>person2完成属性注入并返回。</p>
</li>
<li><p>person2被addSingleton(beanName, singletonObject);中singletonObjects.put(beanName, singletonObject)缓存，并删除singletonFactories.remove(beanName);earlySingletonObjects.remove(beanName);</p>
</li>
<li><p>person1在5步获取到person2的对象并完成属性注入</p>
</li>
<li><p>person1对象返回（因为一开始person2获取的是person1的引用，此时person1完成注入是能看到注入后的对象）</p>
</li>
<li><p>person1被addSingleton(beanName, singletonObject);中singletonObjects.put(beanName, singletonObject)缓存，并删除singletonFactories.remove(beanName);earlySingletonObjects.remove(beanName);</p>
</li>
<li><p>返回最终的person1对象</p>
</li>
</ol>
<h4 id="关于三个map（三级缓存）"><a href="#关于三个map（三级缓存）" class="headerlink" title="关于三个map（三级缓存）"></a>关于三个map（三级缓存）</h4><p>在出现循环依赖时，三个map之间的流程如下：</p>
<ol>
<li><p>先从singletonFactories获取工厂，并通过getObject获取对象并移除缓存，将对象缓存到earlySingletonObjects</p>
</li>
<li><p>通过earlySingletonObjects获取提前曝光的对象</p>
</li>
<li><p>对象创建并初始化完成之后，对象信息保留在singletonObjects并移除过earlySingletonObjects中的缓存</p>
</li>
</ol>
<h4 id="earlySingletonObjects二级缓存是鸡肋吗？"><a href="#earlySingletonObjects二级缓存是鸡肋吗？" class="headerlink" title="earlySingletonObjects二级缓存是鸡肋吗？"></a>earlySingletonObjects二级缓存是鸡肋吗？</h4><p>在创建 beanB 需要引用 beanA 这个“半成品”的时候，就会触发”前期引用”，即如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 三级缓存有的话，就把他移动到二级缓存</span></span><br><span class="line">    singletonObject = singletonFactory.getObject();</span><br><span class="line">    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>singletonFactory.getObject() 是一个接口方法，这里具体的实现方法在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 这么一大段就这句话是核心，也就是当bean要进行提前曝光时，</span></span><br><span class="line">                <span class="comment">// 给一个机会，通过重写后置处理器的getEarlyBeanReference方法，来自定义操作bean</span></span><br><span class="line">                <span class="comment">// 值得注意的是，如果提前曝光了，但是没有被提前引用，则该后置处理器并不生效!!!</span></span><br><span class="line">                <span class="comment">// 这也正式三级缓存存在的意义，否则二级缓存就可以解决循环依赖的问题</span></span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是 Spring 为什么使用三级缓存，而不是二级缓存的原因，它的目的是为了后置处理，如果没有 AOP 后置处理，就不会走进 if 语句，直接返回了 exposedObject ，相当于啥都没干，二级缓存就够用了。</p>
<p>所以又得出结论，这个三级缓存应该和 AOP 有关系，继续。</p>
<p>在 Spring 的源码中getEarlyBeanReference 是 SmartInstantiationAwareBeanPostProcessor 接口的默认方法，真正实现这个方法的只有AbstractAutoProxyCreator 这个类，用于提前曝光的 AOP 代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">   <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">   <span class="comment">// 对bean进行提前Spring AOP代理</span></span><br><span class="line">   <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道 Spring AOP、事务等都是通过代理对象来实现的，而事务的代理对象是由自动代理创建器来自动完成的。也就是说 Spring 最终给我们放进容器里面的是一个代理对象，而非原始对象，假设我们有如下一段业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Hello JavaKeeper"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此 Service 类使用到了事务，所以最终会生成一个 JDK 动态代理对象 Proxy。刚好它又存在自己引用自己的循环依赖，完美符合我们的场景需求。</p>
<p>我们再自定义一个后置处理，来看下效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProcessor</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提前曝光了："</span>+beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用方法栈中有我们自己实现的 HelloProcessor，说明这个 bean 会通过 AOP 代理处理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c3129d1e264fd5abf64fb40643f8e0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>再从源码看下这个自己循环自己的 bean 的创建流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123; </span><br><span class="line">        <span class="comment">// 添加 bean 工厂对象到 singletonFactories 缓存中，并获取原始对象的早期引用</span></span><br><span class="line">        <span class="comment">//匿名内部方法 getEarlyBeanReference 就是后置处理器  </span></span><br><span class="line">        <span class="comment">// SmartInstantiationAwareBeanPostProcessor 的一个方法，</span></span><br><span class="line">        <span class="comment">// 它的功效为：保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从      三级缓存转移到二级缓存里</span></span><br><span class="line">    <span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时后续的这两步操作还是用的 exposedObject，它仍旧是原始对象~~~</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference 创建代理后，initializeBean 就不会再重复创建了，二选一的）</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 所以经过这两大步后，exposedObject 还是原始对象，通过 getEarlyBeanReference 创建的代理对象还在三级缓存呢</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环依赖校验</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里再去调用一次getObject()方法了~~~，此时代理对象还在二级缓存，所以这里拿出来的就是个 代理对象</span></span><br><span class="line">        <span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line">        <span class="comment">// 这样就保证了我们容器里 最终实际上是代理对象，而非原始对象~~~~~</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123; </span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下相关代码，假设我们现在是二级缓存架构，创建 A 的时候，我们不知道有没有循环依赖，所以放入二级缓存提前暴露，接着创建 B，也是放入二级缓存，这时候发现又循环依赖了 A，就去二级缓存找，是有，但是如果此时还有 AOP 代理呢，我们要的是代理对象可不是原始对象，这怎么办，只能改逻辑，在第一步的时候，不管3721，所有 Bean 统统去完成 AOP 代理，如果是这样的话，就不需要三级缓存了，但是这样不仅没有必要，而且违背了 Spring 在结合 AOP 跟 Bean 的生命周期的设计。</p>
<p>所以 Spring “多此一举”的将实例先封装到 ObjectFactory 中（三级缓存），主要关键点在 getObject() 方法并非直接返回实例，而是对实例又使用 SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference 方法对 bean 进行处理，也就是说，当 Spring 中存在该后置处理器，所有的单例 bean 在实例化后都会被进行提前曝光到三级缓存中，但是并不是所有的 bean 都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的 bean 才会进行该后置处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">             <span class="comment">// 三级缓存获取，key=beanName value=objectFactory，objectFactory中存储                    //getObject()方法用于获取提前曝光的实例</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 三级缓存有的话，就把他移动到二级缓存</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">            <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 添加 bean 工厂对象到 singletonFactories 缓存中，并获取原始对象的早期引用</span></span><br><span class="line">   <span class="comment">//匿名内部方法 getEarlyBeanReference 就是后置处理器</span></span><br><span class="line">   <span class="comment">// SmartInstantiationAwareBeanPostProcessor 的一个方法，</span></span><br><span class="line">   <span class="comment">// 它的功效为：保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line">   addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AOP 代理对象提前放入了三级缓存，没有经过属性填充和初始化，这个代理又是如何保证依赖属性的注入的呢？</p>
<p>这个又涉及到了 Spring 中动态代理的实现，不管是cglib代理还是jdk动态代理生成的代理类，代理时，会将目标对象 target 保存在最后生成的代理 $proxy 中，当调用 $proxy 方法时会回调 h.invoke，而 h.invoke 又会回调目标对象 target 的原始方法。所有，其实在 AOP 动态代理时，原始 bean 已经被保存在 提前曝光代理中了，之后 原始 bean 继续完成属性填充和初始化操作。因为 AOP 代理$proxy 中保存着 traget 也就是是 原始bean 的引用，因此后续 原始bean 的完善，也就相当于Spring AOP中的 target 的完善，这样就保证了 AOP 的属性填充与初始化了！</p>
<p>earlySingletonObjects缓存的目的是，通过三级缓存在获取对象会执行一些列的后置处理器，通过earlySingletonObjects来缓存提升性能。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://i.loli.net/2020/01/13/pwAdGtVaRcoCMuB.png" alt="总结1.PNG"></p>
<p><img src="https://i.loli.net/2020/01/13/7mUZQsxcp9WGabD.png" alt="总结2.PNG"></p>
<p><a href="https://zhuanlan.zhihu.com/p/29344811" target="_blank" rel="noopener">参考文章</a></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年10月06日 11:32</p>
        <p>原始链接： <a class="post-url" href="/2020/01/13/Spring_01IOC/" title="IOC、循环依赖的解决">https://guoshusong.github.io/2020/01/13/Spring_01IOC/</a></p>
        <footer>
            <a href="https://guoshusong.github.io">
                <img src="/images/logo.png" alt="GuoShuSong">
                GuoShuSong
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://guoshusong.github.io/2020/01/13/Spring_01IOC/&title=《IOC、循环依赖的解决》 — gssplus's Blog&pic=https://i.loli.net/2020/06/02/tFQRdryksBI1uvL.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://guoshusong.github.io/2020/01/13/Spring_01IOC/&title=《IOC、循环依赖的解决》 — gssplus's Blog&source=IOC简介及原理、Bean的生命周期、循环依赖的解决" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://guoshusong.github.io/2020/01/13/Spring_01IOC/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《IOC、循环依赖的解决》 — gssplus's Blog&url=https://guoshusong.github.io/2020/01/13/Spring_01IOC/&via=https://guoshusong.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://guoshusong.github.io/2020/01/13/Spring_01IOC/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://guoshusong.github.io/2020/01/13/Spring_01IOC/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/SpringBoot/" class="color1">SpringBoot</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IOC简介及原理、Bean的生命周期、循环依赖的解决"><span class="post-toc-text">IOC简介及原理、Bean的生命周期、循环依赖的解决</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IOC简介"><span class="post-toc-text">IOC简介</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IOC原理"><span class="post-toc-text">IOC原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BeanFactory的继承体系"><span class="post-toc-text">BeanFactory的继承体系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ApplicationContext的继承体系："><span class="post-toc-text">ApplicationContext的继承体系：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BeanFactory生命周期"><span class="post-toc-text">BeanFactory生命周期</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ApplicationContext生命周期"><span class="post-toc-text">ApplicationContext生命周期</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ApplicationContext和BeanFactory不同之处在于："><span class="post-toc-text">ApplicationContext和BeanFactory不同之处在于：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Bean的初始化过程"><span class="post-toc-text">Bean的初始化过程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IOC容器装配Bean"><span class="post-toc-text">IOC容器装配Bean</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#装配方式"><span class="post-toc-text">装配方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#依赖注入方式"><span class="post-toc-text">依赖注入方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对象之间的关系"><span class="post-toc-text">对象之间的关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Bean的作用域"><span class="post-toc-text">Bean的作用域</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#循环依赖"><span class="post-toc-text">循环依赖</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#获取Bean流程"><span class="post-toc-text">获取Bean流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#属性注入与循环依赖"><span class="post-toc-text">属性注入与循环依赖</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#spring属性注入处理循环依赖的方式"><span class="post-toc-text">spring属性注入处理循环依赖的方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#spring循环依赖处理几个关键位置："><span class="post-toc-text">spring循环依赖处理几个关键位置：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#假设我们从beanfactory获取person1对象，-循环依赖处理流程如下："><span class="post-toc-text">假设我们从beanfactory获取person1对象， 循环依赖处理流程如下：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#关于三个map（三级缓存）"><span class="post-toc-text">关于三个map（三级缓存）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#earlySingletonObjects二级缓存是鸡肋吗？"><span class="post-toc-text">earlySingletonObjects二级缓存是鸡肋吗？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#总结-1"><span class="post-toc-text">总结</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/01/13/Spring_00%E9%9D%A2%E8%AF%95%E5%9F%BA%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          SpringBoot面试题
        
      </span>
    </a>
  
  
    <a href="/2020/01/12/Mysql2/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">MySQL事务及事务的各种隔离级别、MVCC介绍</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      

      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 GuoShuSong<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://guoshusong.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Java/">Java</a><a class="category-link" href="/categories/MySQL/">MySQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/SpringBoot/">SpringBoot</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><a class="category-link" href="/categories/%E7%90%90%E7%A2%8E/">琐碎</a><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>