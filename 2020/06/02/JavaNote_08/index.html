<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java线程基础 | gssplus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="gss's Blog" />
  
  <meta name="description" content="线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程基础">
<meta property="og:url" content="https://guoshusong.github.io/2020/06/02/JavaNote_08/index.html">
<meta property="og:site_name" content="gssplus&#39;s Blog">
<meta property="og:description" content="线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/11/10/16e532817f707795?w=982&h=706&f=png&s=99918">
<meta property="og:image" content="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/java-thread_1.png">
<meta property="article:published_time" content="2020-06-02T06:08:50.497Z">
<meta property="article:modified_time" content="2020-10-16T12:15:50.334Z">
<meta property="article:author" content="GuoShuSong">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/11/10/16e532817f707795?w=982&h=706&f=png&s=99918">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Hello,Here is gssplus!</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Hello,Here is gssplus!
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        我见过春日夏风，秋月冬雪，也曾踏遍南水北山，东麓西岭，可这四季春秋，苍山央水，都不及你瞅我展眉一笑
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="//guoshusong.github.io/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/guoshusong">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-JavaNote_08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Java线程基础
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Java/">Java</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-06-02
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别"><a href="#线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别" class="headerlink" title="线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别"></a>线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别</h2><a id="more"></a>

<blockquote>
<p><strong><em>关键词：<code>Thread</code>、<code>Runnable</code>、<code>Callable</code>、<code>Future</code>、<code>wait</code>、<code>notify</code>、<code>notifyAll</code>、<code>join</code>、<code>sleep</code>、<code>yeild</code>、<code>线程状态</code>、<code>线程通信</code></em></strong></p>
</blockquote>
<h3 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h3><h4 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1. 什么是进程"></a>1.1. 什么是进程</h4><p>简言之，<strong>进程可视为一个正在运行的程序</strong>。它是系统运行程序的基本单位，因此进程是动态的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。</p>
<h4 id="1-2-什么是线程"><a href="#1-2-什么是线程" class="headerlink" title="1.2. 什么是线程"></a>1.2. 什么是线程</h4><p>线程是操作系统进行调度的基本单位。线程也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<h4 id="1-3-进程和线程的区别"><a href="#1-3-进程和线程的区别" class="headerlink" title="1.3. 进程和线程的区别"></a>1.3. 进程和线程的区别</h4><ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高。</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
<h4 id="1-4-线程优先级"><a href="#1-4-线程优先级" class="headerlink" title="1.4. 线程优先级"></a>1.4. 线程优先级</h4><p>单核计算机只有一个CPU，各个线程轮流获得CPU的使用权，才能执行任务：</p>
<ul>
<li>优先级较高的线程有更多获得CPU的机会，反之亦然；</li>
<li>优先级用整数表示，取值范围是1~10，一般情况下，线程的默认</li>
<li>优先级都是5，但是也可以通过setPriority和getPriority方法来设置或返回优先级；</li>
</ul>
<p><strong> <code>Thread</code>类有如下3个静态常量来表示优先级：</strong></p>
<ul>
<li>MAX_PRIORITY：取值为10，表示最高优先级</li>
<li>MIN_PRIORITY：取值为1，表示最低优先级</li>
<li>NORM_PRIORITY：取值为5，表示默认的优先级</li>
</ul>
<h4 id="1-5-线程的生命周期"><a href="#1-5-线程的生命周期" class="headerlink" title="1.5. 线程的生命周期"></a>1.5. 线程的生命周期</h4><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e532817f707795?w=982&h=706&f=png&s=99918" alt=""></p>
<p>1、新建状态（New）：新创建了一个线程对象。</p>
<p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</p>
<p>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</p>
<p>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<p>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</p>
<p>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</p>
<p>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<p><strong> 线程在Running的过程中可能会遇到阻塞(Blocked)情况：</strong></p>
<ul>
<li>调用<code>join()</code>和<code>sleep()</code>方法，<code>sleep()</code>时间结束或被打断，<code>join()</code>中断,IO完成都会回到<code>Runnable</code>状态，等待JVM的调度。</li>
<li>调用<code>wait()</code>，使该线程处于等待池(wait blocked pool),直到<code>notify()</code>/<code>notifyAll()</code>，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable）</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
</ul>
<h3 id="2-线程创建方式"><a href="#2-线程创建方式" class="headerlink" title="2 线程创建方式"></a>2 线程创建方式</h3><p><strong> 线程创建方式：</strong></p>
<ul>
<li><strong>实现Runnable接口，重载<code>run()</code>，无返回值</strong></li>
<li><strong>继承Thread类，复写<code>run()</code></strong></li>
<li><strong>实现Callable接口，通过FutureTask/Future来创建有返回值的Thread线程，通过Executor执行</strong></li>
<li><strong>使用Executors创建ExecutorService，入参Callable或Future</strong></li>
</ul>
<h4 id="2-1-实现Runnable接口"><a href="#2-1-实现Runnable接口" class="headerlink" title="2.1. 实现Runnable接口"></a>2.1. 实现Runnable接口</h4><p><strong>实现 <code>Runnable</code> 接口优于继承 <code>Thread</code> 类</strong>，因为：</p>
<ul>
<li>Java 不支持多重继承，所有的类都只允许继承一个父类，但可以实现多个接口。如果继承了 <code>Thread</code> 类就无法继承其它类，这不利于扩展。</li>
<li>类可能只要求可执行就行，继承整个 <code>Thread</code> 类开销过大。</li>
</ul>
<p>通过实现 <code>Runnable</code> 接口创建线程的步骤：</p>
<ol>
<li>定义 <code>Runnable</code> 接口的实现类，并覆写该接口的 <code>run</code> 方法。该 <code>run</code> 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并以此实例作为 <code>Thread</code> 的 target 来创建 <code>Thread</code> 对象，该 <code>Thread</code> 对象才是真正的线程对象。</li>
<li>调用线程对象的 <code>start</code> 方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        Thread tA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(), <span class="string">"Runnable 线程-A"</span>);</span><br><span class="line">        Thread tB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(), <span class="string">"Runnable 线程-B"</span>);</span><br><span class="line">        <span class="comment">// 调用线程主体</span></span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + ticket + <span class="string">" 张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-继承Thread类"><a href="#2-2-继承Thread类" class="headerlink" title="2.2. 继承Thread类"></a>2.2. 继承Thread类</h4><p>通过继承 <code>Thread</code> 类创建线程的步骤：</p>
<ol>
<li>定义 <code>Thread</code> 类的子类，并覆写该类的 <code>run</code> 方法。<code>run</code> 方法的方法体就代表了线程要完成的任务，因此把 <code>run</code> 方法称为执行体。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start</code> 方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        MyThread tA = <span class="keyword">new</span> MyThread(<span class="string">"Thread 线程-A"</span>);</span><br><span class="line">        MyThread tB = <span class="keyword">new</span> MyThread(<span class="string">"Thread 线程-B"</span>);</span><br><span class="line">        <span class="comment">// 调用线程主体</span></span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        MyThread(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + ticket + <span class="string">" 张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Callable、Future、FutureTask"><a href="#2-3-Callable、Future、FutureTask" class="headerlink" title="2.3. Callable、Future、FutureTask"></a>2.3. Callable、Future、FutureTask</h4><p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></p>
<p><strong>继承 Thread 类和实现 Runnable 接口这两种创建线程的方式都没有返回值</strong>。所以，线程执行完后，无法得到执行结果。但如果期望得到执行结果该怎么做？</p>
<p>为了解决这个问题，Java 1.5 后，提供了 <code>Callable</code> 接口和 <code>Future</code> 接口，通过它们，可以在线程执行结束后，返回执行结果。</p>
<h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>Callable 接口只声明了一个方法，这个方法叫做 call()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么怎么使用 Callable 呢？一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个 submit 方法的重载版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>第一个 submit 方法里面的参数类型就是 Callable。</p>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>Future 就是对于具体的 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>FutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口和 Future 接口。</p>
<p>所以，FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，FutureTask 是 Future 接口的一个唯一实现类。</p>
<h5 id="Callable-Future-FutureTask-示例"><a href="#Callable-Future-FutureTask-示例" class="headerlink" title="Callable + Future + FutureTask 示例"></a>Callable + Future + FutureTask 示例</h5><p>通过实现 <code>Callable</code> 接口创建线程的步骤：</p>
<ol>
<li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call</code> 方法。该 <code>call</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 target 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get</code> 方法来获得线程执行结束后的返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callable&lt;Long&gt; callable = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask&lt;Long&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(future, <span class="string">"Callable 线程"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"任务耗时："</span> + (future.get() / <span class="number">1000000</span>) + <span class="string">"毫秒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 卖出了第 "</span> + ticket + <span class="string">" 张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">            <span class="keyword">return</span> (end - begin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Runnable接口和Callable接口区别</p>
</blockquote>
<p>1）两个接口需要实现的方法名不一样，Runnable需要实现的方法为<code>run()</code>，Callable需要实现的方法为<code>call()</code>。<br>2）实现的方法返回值不一样，Runnable任务执行后无返回值，Callable任务执行后可以得到异步计算的结果。<br>3）抛出异常不一样，Runnable不可以抛出异常，Callable可以抛出异常。 </p>
<p><strong>4.使用Executors创建ExecutorService，入参Callable或Future，适用于线程池和并发</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExecutors</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadExecutors</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> ThreadFactory <span class="title">createThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadFactory tf = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.setName(threadName);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> tf;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">runCallable</span><span class="params">(Callable callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Executors.newSingleThreadExecutor(createThread()).submit(callable);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">runFunture</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Executors.newSingleThreadExecutor(createThread()).submit(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ThreadExecutors threadExecutors = <span class="keyword">new</span> ThreadExecutors(<span class="string">"callableThread"</span>);</span><br><span class="line">    threadExecutors.runCallable(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    threadExecutors.runFunture(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute runnable thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-线程基本用法"><a href="#3-线程基本用法" class="headerlink" title="3. 线程基本用法"></a>3. 线程基本用法</h4><p>线程（<code>Thread</code>）基本方法清单：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>run</code></td>
<td>线程的执行实体。</td>
</tr>
<tr>
<td><code>start</code></td>
<td>线程的启动方法。</td>
</tr>
<tr>
<td><code>currentThread</code></td>
<td>返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td><code>setName</code></td>
<td>设置线程名称。</td>
</tr>
<tr>
<td><code>getName</code></td>
<td>获取线程名称。</td>
</tr>
<tr>
<td><code>setPriority</code></td>
<td>设置线程优先级。Java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 5。</td>
</tr>
<tr>
<td><code>getPriority</code></td>
<td>获取线程优先级。</td>
</tr>
<tr>
<td><code>setDaemon</code></td>
<td>设置线程为守护线程。</td>
</tr>
<tr>
<td><code>isDaemon</code></td>
<td>判断线程是否为守护线程。</td>
</tr>
<tr>
<td><code>isAlive</code></td>
<td>判断线程是否启动。</td>
</tr>
<tr>
<td><code>interrupt</code></td>
<td>中断另一个线程的运行状态。</td>
</tr>
<tr>
<td><code>interrupted</code></td>
<td>测试当前线程是否已被中断。通过此方法可以清除线程的中断状态。换句话说，如果要连续调用此方法两次，则第二次调用将返回 false（除非当前线程在第一次调用清除其中断状态之后且在第二次调用检查其状态之前再次中断）。</td>
</tr>
<tr>
<td><code>join</code></td>
<td>可以使一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。</td>
</tr>
<tr>
<td><code>Thread.sleep</code></td>
<td>静态方法。将当前正在执行的线程休眠。</td>
</tr>
<tr>
<td><code>Thread.yield</code></td>
<td>静态方法。将当前正在执行的线程暂停，让其他线程执行。</td>
</tr>
</tbody></table>
<h4 id="3-1-线程休眠"><a href="#3-1-线程休眠" class="headerlink" title="3.1. 线程休眠"></a>3.1. 线程休眠</h4><p><strong>使用 <code>Thread.sleep</code> 方法可以使得当前正在执行的线程进入休眠状态。</strong></p>
<p>使用 <code>Thread.sleep</code> 需要向其传入一个整数值，这个值表示线程将要休眠的毫秒数。</p>
<p><code>Thread.sleep</code> 方法可能会抛出 <code>InterruptedException</code>，因为异常不能跨线程传播回 <code>main</code> 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">"线程A"</span>, <span class="number">500</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">"线程B"</span>, <span class="number">1000</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(<span class="string">"线程C"</span>, <span class="number">1500</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 线程名称 */</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 休眠时间 */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MyThread</span><span class="params">(String name, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 休眠指定的时间</span></span><br><span class="line">                Thread.sleep(<span class="keyword">this</span>.time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"休眠"</span> + <span class="keyword">this</span>.time + <span class="string">"毫秒。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-线程礼让"><a href="#3-2-线程礼让" class="headerlink" title="3.2. 线程礼让"></a>3.2. 线程礼让</h4><p><code>Thread.yield</code> 方法的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行 。</p>
<p>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(t, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"运行，i = "</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">"线程礼让："</span>);</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-终止线程"><a href="#3-3-终止线程" class="headerlink" title="3.3. 终止线程"></a>3.3. 终止线程</h4><blockquote>
<p><strong><code>Thread</code> 中的 <code>stop</code> 方法有缺陷，已废弃</strong>。</p>
<p>使用 <code>Thread.stop</code> 停止线程会导致它解锁所有已锁定的监视器（由于未经检查的 <code>ThreadDeath</code> 异常会在堆栈中传播，这是自然的结果）。 如果先前由这些监视器保护的任何对象处于不一致状态，则损坏的对象将对其他线程可见，从而可能导致任意行为。<code>Thread.stop</code> 的许多用法应由仅修改某些变量以指示目标线程应停止运行的代码代替。 目标线程应定期检查此变量，如果该变量指示要停止运行，则应按有序方式从其运行方法返回。如果目标线程等待很长时间（例如，在条件变量上），则应使用中断方法来中断等待。</p>
</blockquote>
<p>当一个线程运行时，另一个线程可以直接通过 <code>interrupt</code> 方法中断其运行状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(); <span class="comment">// 实例化Runnable子类对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt, <span class="string">"线程"</span>); <span class="comment">// 实例化Thread对象</span></span><br><span class="line">        t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 线程休眠2秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"3、休眠被终止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"1、进入run()方法"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">// 线程休眠10秒</span></span><br><span class="line">                System.out.println(<span class="string">"2、已经完成了休眠"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"3、休眠被终止"</span>);</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 返回调用处</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"4、run()方法正常结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个线程的 <code>run</code> 方法执行一个无限循环，并且没有执行 <code>sleep</code> 等会抛出 <code>InterruptedException</code> 的操作，那么调用线程的 <code>interrupt</code> 方法就无法使线程提前结束。</p>
<p>但是调用 <code>interrupt</code> 方法会设置线程的中断标记，此时调用 <code>interrupted</code> 方法会返回 <code>true</code>。因此可以在循环体中使用 <code>interrupted</code> 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<p>安全地终止线程有两种方法：</p>
<ul>
<li>定义 <code>volatile</code> 标志位，在 <code>run</code> 方法中使用标志位控制线程终止</li>
<li>使用 <code>interrupt</code> 方法和 <code>Thread.interrupted</code> 方法配合使用来控制线程终止</li>
</ul>
<p>示例：使用 <code>volatile</code> 标志位控制线程终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task, <span class="string">"MyTask"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        task.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程启动"</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                System.out.println(count++);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程终止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 volatile 标志位来控制线程终止</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：使用 <code>interrupt</code> 方法和 <code>Thread.interrupted</code> 方法配合使用来控制线程终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(task, <span class="string">"MyTask"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程启动"</span>);</span><br><span class="line">            <span class="comment">// 通过 Thread.interrupted 和 interrupt 配合来控制线程终止</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(count++);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程终止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-线程通信"><a href="#4-线程通信" class="headerlink" title="4. 线程通信"></a>4. 线程通信</h3><blockquote>
<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
</blockquote>
<h4 id="4-1-wait-notify-notifyAll"><a href="#4-1-wait-notify-notifyAll" class="headerlink" title="4.1. wait/notify/notifyAll"></a>4.1. wait/notify/notifyAll</h4><ul>
<li><code>wait</code> - <code>wait</code> 会自动释放当前线程占有的对象锁，并请求操作系统挂起当前线程，<strong>让线程从 <code>Running</code> 状态转入 <code>Waiting</code> 状态</strong>，等待 <code>notify</code> / <code>notifyAll</code> 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify</code> 或者 <code>notifyAll</code> 来唤醒挂起的线程，造成死锁。</li>
<li><code>notify</code> - 唤醒一个正在 <code>Waiting</code> 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 。</li>
<li><code>notifyAll</code> - 唤醒所有正在 <code>Waiting</code> 状态的线程，接下来它们需要竞争对象锁。</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li><strong><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 都是 <code>Object</code> 类中的方法</strong>，而非 <code>Thread</code>。</li>
<li><strong><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 只能用在 <code>synchronized</code> 方法或者 <code>synchronized</code> 代码块中使用，否则会在运行时抛出 <code>IllegalMonitorStateException</code></strong>。</li>
</ul>
<p>为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 不定义在 <code>Thread</code> 中？为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 要配合 <code>synchronized</code> 使用？</p>
<p>首先，需要了解几个基本知识点：</p>
<ul>
<li>每一个 Java 对象都有一个与之对应的 <strong>监视器（monitor）</strong></li>
<li>每一个监视器里面都有一个 <strong>对象锁</strong> 、一个 <strong>等待队列</strong>、一个 <strong>同步队列</strong></li>
</ul>
<p>了解了以上概念，我们回过头来理解前面两个问题。</p>
<p>为什么这几个方法不定义在 <code>Thread</code> 中？</p>
<p>由于每个对象都拥有对象锁，让当前线程等待某个对象锁，自然应该基于这个对象（<code>Object</code>）来操作，而非使用当前线程（<code>Thread</code>）来操作。因为当前线程可能会等待多个线程的锁，如果基于线程（<code>Thread</code>）来操作，就非常复杂了。</p>
<p>为什么 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 要配合 <code>synchronized</code> 使用？</p>
<p>如果调用某个对象的 <code>wait</code> 方法，当前线程必须拥有这个对象的对象锁，因此调用 <code>wait</code> 方法必须在 <code>synchronized</code> 方法和 <code>synchronized</code> 代码块中。</p>
</blockquote>
<p>生产者、消费者模式是 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 的一个经典使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitNotifyDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(QUEUE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">"生产者A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">"生产者B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(<span class="string">"消费者A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(<span class="string">"消费者B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Consumer(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"队列空，等待数据"</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notifyAll();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll(); <span class="comment">// 每次移走队首元素</span></span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 从队列取走一个元素，队列当前有："</span> + queue.size() + <span class="string">"个元素"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Producer(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == QUEUE_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"队列满，等待有空余空间"</span>);</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notifyAll();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(<span class="number">1</span>); <span class="comment">// 每次插入一个元素</span></span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" 向队列取中插入一个元素，队列当前有："</span> + queue.size() + <span class="string">"个元素"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-join"><a href="#4-2-join" class="headerlink" title="4.2. join"></a>4.2. join</h4><p>在线程操作中，可以使用 <code>join</code> 方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(); <span class="comment">// 实例化Runnable子类对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt, <span class="string">"mythread"</span>); <span class="comment">// 实例化Thread对象</span></span><br><span class="line">        t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.join(); <span class="comment">// 线程强制运行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Main 线程运行 --&gt; "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 运行，i = "</span> + i); <span class="comment">// 取得当前线程的名字</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-管道"><a href="#4-3-管道" class="headerlink" title="4.3. 管道"></a>4.3. 管道</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。<br>管道输入/输出流主要包括了如下 4 种具体实现：<code>PipedOutputStream</code>、<code>PipedInputStream</code>、<code>PipedReader</code> 和 <code>PipedWriter</code>，前两种面向字节，而后两种面向字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        Print(PipedReader in) &#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-线程状态"><a href="#5-线程状态" class="headerlink" title="5. 线程状态"></a>5. 线程状态</h3><p><img src="http://dunwu.test.upcdn.net/cs/java/javacore/concurrent/java-thread_1.png" alt="img"></p>
<p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><p><strong>新建（New）</strong> - 尚未调用 <code>start</code> 方法的线程处于此状态。此状态意味着：<strong>创建的线程尚未启动</strong>。</p>
</li>
<li><p><strong>就绪（Runnable）</strong> - 已经调用了 <code>start</code> 方法的线程处于此状态。此状态意味着：<strong>线程已经在 JVM 中运行</strong>。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p>
</li>
<li><p><strong>阻塞（Blocked）</strong> - 表示线程在等待 Monitor lock，从而进入 <code>synchronized</code> 函数或者代码块，但是其它线程已经占用了该 Monitor lock，所以处于阻塞状态。要结束该状态进入 <code>Runnable</code>，从而需要其他线程释放 Monitor lock。此状态意味着：<strong>线程处于被阻塞状态</strong>。</p>
</li>
<li><p><strong>等待（Waiting）</strong> - 此状态意味着：<strong>线程等待被其他线程显式地唤醒</strong>。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 Monitor lock。而等待是主动的，通过调用 <code>Object.wait</code> 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 <code>Object.wait</code> 方法</td>
<td><code>Object.notify</code> / <code>Object.notifyAll</code></td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 <code>Thread.join</code> 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.park</code> 方法</td>
<td><code>LockSupport.unpark</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>定时等待（Timed waiting）</strong> - 此状态意味着：<strong>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</strong>。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>Thread.sleep</code> 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 <code>Object.wait</code> 方法</td>
<td>时间结束 / <code>Object.notify</code> / <code>Object.notifyAll</code></td>
</tr>
<tr>
<td>设置了 Timeout 参数的 <code>Thread.join</code> 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td><code>LockSupport.parkNanos</code> 方法</td>
<td><code>LockSupport.unpark</code></td>
</tr>
<tr>
<td><code>LockSupport.parkUntil</code> 方法</td>
<td><code>LockSupport.unpark</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>终止(Terminated)</strong> - 线程 <code>run</code> 方法执行结束，或者因异常退出了 <code>run</code> 方法。此状态意味着：线程结束了生命周期。</p>
</li>
</ul>
<h3 id="6-sleep、yield、wait、join的区别"><a href="#6-sleep、yield、wait、join的区别" class="headerlink" title="6. sleep、yield、wait、join的区别"></a>6. sleep、yield、wait、join的区别</h3><ol>
<li><p>sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁  可通过调用interrupt()方法来唤醒休眠线程。</p>
</li>
<li><p>yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p>
</li>
<li><p>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</p>
</li>
<li><p>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</p>
</li>
</ol>
<p>等待调用join方法的线程结束，再继续执行。如：t.join();主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p>
<h4 id="6-1-为什么-sleep-和-yield-方法是静态的"><a href="#6-1-为什么-sleep-和-yield-方法是静态的" class="headerlink" title="6.1. 为什么 sleep 和 yield 方法是静态的"></a>6.1. 为什么 sleep 和 yield 方法是静态的</h4><p><code>Thread</code> 类的 <code>sleep</code> 和 <code>yield</code> 方法将处理 <code>Running</code> 状态的线程。</p>
<p>所以在其他处于非 <code>Running</code> 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<h3 id="6-2-一个线程两次调用-start-方法会怎样"><a href="#6-2-一个线程两次调用-start-方法会怎样" class="headerlink" title="6.2. 一个线程两次调用 start()方法会怎样"></a>6.2. 一个线程两次调用 start()方法会怎样</h3><p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p>
<h3 id="7-3-start-和-run-方法有什么区别"><a href="#7-3-start-和-run-方法有什么区别" class="headerlink" title="7.3. start 和 run 方法有什么区别"></a>7.3. <code>start</code> 和 <code>run</code> 方法有什么区别</h3><ul>
<li><code>run</code> 方法是线程的执行体。</li>
<li><code>start</code> 方法会启动线程，然后 JVM 会让这个线程去执行 <code>run</code> 方法。</li>
</ul>
<h3 id="7-4-可以直接调用-Thread-类的-run-方法么"><a href="#7-4-可以直接调用-Thread-类的-run-方法么" class="headerlink" title="7.4. 可以直接调用 Thread 类的 run 方法么"></a>7.4. 可以直接调用 <code>Thread</code> 类的 <code>run</code> 方法么</h3><ul>
<li>可以。但是如果直接调用 <code>Thread</code> 的 <code>run</code> 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 <code>Thread</code> 的 <code>start</code> 方法。</li>
</ul>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年10月16日 20:15</p>
        <p>原始链接： <a class="post-url" href="/2020/06/02/JavaNote_08/" title="Java线程基础">https://guoshusong.github.io/2020/06/02/JavaNote_08/</a></p>
        <footer>
            <a href="https://guoshusong.github.io">
                <img src="/images/logo.png" alt="GuoShuSong">
                GuoShuSong
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://guoshusong.github.io/2020/06/02/JavaNote_08/&title=《Java线程基础》 — gssplus's Blog&pic=https://i.loli.net/2020/06/02/kRu437CeQYzhwWv.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://guoshusong.github.io/2020/06/02/JavaNote_08/&title=《Java线程基础》 — gssplus's Blog&source=线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://guoshusong.github.io/2020/06/02/JavaNote_08/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java线程基础》 — gssplus's Blog&url=https://guoshusong.github.io/2020/06/02/JavaNote_08/&via=https://guoshusong.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://guoshusong.github.io/2020/06/02/JavaNote_08/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://guoshusong.github.io/2020/06/02/JavaNote_08/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java基础/" class="color2">Java基础</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别"><span class="post-toc-text">线程基本概念、锁、进程间通信、sleep、yield、wait、join的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-线程简介"><span class="post-toc-text">1. 线程简介</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-1-什么是进程"><span class="post-toc-text">1.1. 什么是进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-什么是线程"><span class="post-toc-text">1.2. 什么是线程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-进程和线程的区别"><span class="post-toc-text">1.3. 进程和线程的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-4-线程优先级"><span class="post-toc-text">1.4. 线程优先级</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-5-线程的生命周期"><span class="post-toc-text">1.5. 线程的生命周期</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-线程创建方式"><span class="post-toc-text">2 线程创建方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-实现Runnable接口"><span class="post-toc-text">2.1. 实现Runnable接口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-继承Thread类"><span class="post-toc-text">2.2. 继承Thread类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-Callable、Future、FutureTask"><span class="post-toc-text">2.3. Callable、Future、FutureTask</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Callable"><span class="post-toc-text">Callable</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Future"><span class="post-toc-text">Future</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#FutureTask"><span class="post-toc-text">FutureTask</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Callable-Future-FutureTask-示例"><span class="post-toc-text">Callable + Future + FutureTask 示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-线程基本用法"><span class="post-toc-text">3. 线程基本用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-线程休眠"><span class="post-toc-text">3.1. 线程休眠</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-线程礼让"><span class="post-toc-text">3.2. 线程礼让</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-终止线程"><span class="post-toc-text">3.3. 终止线程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-线程通信"><span class="post-toc-text">4. 线程通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-wait-notify-notifyAll"><span class="post-toc-text">4.1. wait&#x2F;notify&#x2F;notifyAll</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-2-join"><span class="post-toc-text">4.2. join</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-管道"><span class="post-toc-text">4.3. 管道</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-线程状态"><span class="post-toc-text">5. 线程状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-sleep、yield、wait、join的区别"><span class="post-toc-text">6. sleep、yield、wait、join的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-为什么-sleep-和-yield-方法是静态的"><span class="post-toc-text">6.1. 为什么 sleep 和 yield 方法是静态的</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-一个线程两次调用-start-方法会怎样"><span class="post-toc-text">6.2. 一个线程两次调用 start()方法会怎样</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-3-start-和-run-方法有什么区别"><span class="post-toc-text">7.3. start 和 run 方法有什么区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-4-可以直接调用-Thread-类的-run-方法么"><span class="post-toc-text">7.4. 可以直接调用 Thread 类的 run 方法么</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/06/02/JavaNote_09/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Java多线程-线程池
        
      </span>
    </a>
  
  
    <a href="/2020/06/02/JavaNote_07/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">设计模式</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      

      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 GuoShuSong<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://guoshusong.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Java/">Java</a><a class="category-link" href="/categories/MySQL/">MySQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/SpringBoot/">SpringBoot</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><a class="category-link" href="/categories/%E7%90%90%E7%A2%8E/">琐碎</a><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 12px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 12px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>