<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaIO相关知识 | gssplus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="gss's Blog" />
  
  <meta name="description" content="同步、异步、阻塞、非阻塞、BIO、NIO、AIO">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaIO相关知识">
<meta property="og:url" content="https://guoshusong.github.io/2020/06/02/JavaNote_10/index.html">
<meta property="og:site_name" content="gssplus&#39;s Blog">
<meta property="og:description" content="同步、异步、阻塞、非阻塞、BIO、NIO、AIO">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3555339dae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb354b4f528e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3554dad1da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35643fde0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3564b442e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a2d1fcac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a30e0c8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a6154ff3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35acd1a4ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35ace1446a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35cd16c41a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35d02b9462?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35e175a721?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35d1ab5ca0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35ed8239eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35f0eb6f29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35f32978aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb362449a684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2020-06-02T06:08:50.502Z">
<meta property="article:modified_time" content="2020-06-27T07:43:07.162Z">
<meta property="article:author" content="GuoShuSong">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3555339dae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Hello,Here is gssplus!</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Hello,Here is gssplus!
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        我见过春日夏风，秋月冬雪，也曾踏遍南水北山，东麓西岭，可这四季春秋，苍山央水，都不及你瞅我展眉一笑
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="//guoshusong.github.io/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/guoshusong">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-JavaNote_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      JavaIO相关知识
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Java/">Java</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-06-02
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="同步、异步、阻塞、非阻塞、BIO、NIO、AIO"><a href="#同步、异步、阻塞、非阻塞、BIO、NIO、AIO" class="headerlink" title="同步、异步、阻塞、非阻塞、BIO、NIO、AIO"></a>同步、异步、阻塞、非阻塞、BIO、NIO、AIO</h2><a id="more"></a>

<h2 id="IO简介"><a href="#IO简介" class="headerlink" title="IO简介"></a>IO简介</h2><p>IO，常写作I/O，是Input/Output的简称，即输入/输出。</p>
<p>通常指数据在内部存储器（内存）和外部存储器（硬盘、优盘等）或其他周边设备之间的输入和输出。输入/输出是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。</p>
<p>输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p>
<p>在Java中，提供了一些列API，可以供开发者来读写外部数据或文件。我们称这些API为Java IO。IO是Java中比较重要，且比较难的知识点，主要是因为随着Java的发展，目前有三种IO共存。分别是BIO、NIO和AIO。</p>
<h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO 全称Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Java NIO，全程 Non-Block IO ，是Java SE 1.4版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。</p>
<p>NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</p>
<p>面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>NIO只有在连接/通道真正有读写事件发生时(事件驱动)，才会进行读写，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p>
<h3 id="NIO的三大核心"><a href="#NIO的三大核心" class="headerlink" title="NIO的三大核心"></a>NIO的三大核心</h3><table>
<thead>
<tr>
<th>NIO的核心</th>
<th>对应的类或接口</th>
<th>应用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>缓冲区</td>
<td>java.nio.Buffer</td>
<td>文件IO/网络IO</td>
<td>存储数据</td>
</tr>
<tr>
<td>通道</td>
<td>java.nio.channels.Channel</td>
<td>文件IO/网络IO</td>
<td>运输</td>
</tr>
<tr>
<td>选择器</td>
<td>java.nio.channels.Selector</td>
<td>网络IO</td>
<td>控制器</td>
</tr>
</tbody></table>
<h4 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h4><h5 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a>什么是缓冲区</h5><p>先看以下这张类图，可以看到Buffer有七种类型。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3555339dae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>Buffer是一个内存块。在NIO中，所有的数据都是用Buffer处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向Stream流，NIO而是面向缓冲区(Buffer)。</p>
<h5 id="常用的类型ByteBuffer"><a href="#常用的类型ByteBuffer" class="headerlink" title="常用的类型ByteBuffer"></a>常用的类型ByteBuffer</h5><p>一般我们常用的类型是ByteBuffer，把数据转成字节进行处理。实质上是一个byte[]数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//存储数据的数组</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">this</span>.hb = hb;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建Buffer的方式"><a href="#创建Buffer的方式" class="headerlink" title="创建Buffer的方式"></a>创建Buffer的方式</h5><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p>
<p>创建堆内内存块(非直接缓冲区)的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建堆内内存块HeapByteBuffer</span></span><br><span class="line">ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">String msg = <span class="string">"java"</span>;</span><br><span class="line"><span class="comment">//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBuffer</span></span><br><span class="line">ByteBuffer byteBuffer2 = ByteBuffer.wrap(msg.getBytes());</span><br></pre></td></tr></table></figure>

<p>创建堆外内存块(直接缓冲区)的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建堆外内存块DirectByteBuffer</span></span><br><span class="line">ByteBuffer byteBuffer3 = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h5 id="HeapByteBuffer与DirectByteBuffer的区别"><a href="#HeapByteBuffer与DirectByteBuffer的区别" class="headerlink" title="HeapByteBuffer与DirectByteBuffer的区别"></a>HeapByteBuffer与DirectByteBuffer的区别</h5><p>其实根据类名就可以看出，HeapByteBuffer所创建的字节缓冲区就是在JVM堆中的，即JVM内部所维护的字节数组。而DirectByteBuffer是直接操作操作系统本地代码创建的内存缓冲数组。<br>DirectByteBuffer的使用场景：</p>
<ol>
<li>java程序与本地磁盘、socket传输数据</li>
</ol>
<ol start="2">
<li>大文件对象，可以使用。不会受到堆内存大小的限制。</li>
</ol>
<ol start="3">
<li>不需要频繁创建，生命周期较长的情况，能重复使用的情况。</li>
</ol>
<p>HeapByteBuffer的使用场景：<br>除了以上的场景外，其他情况还是建议使用HeapByteBuffer，没有达到一定的量级，实际上使用DirectByteBuffer是体现不出优势的。</p>
<h5 id="Buffer的初体验"><a href="#Buffer的初体验" class="headerlink" title="Buffer的初体验"></a>Buffer的初体验</h5><p>接下来，使用ByteBuffer做一个小例子，熟悉一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       String msg = <span class="string">"java"</span>;</span><br><span class="line">       <span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">       <span class="keyword">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">       <span class="comment">//写入数据到Buffer中</span></span><br><span class="line">       byteBuffer.put(bytes);</span><br><span class="line">       <span class="comment">//切换成读模式，关键一步</span></span><br><span class="line">       byteBuffer.flip();</span><br><span class="line">       <span class="comment">//创建一个临时数组，用于存储获取到的数据</span></span><br><span class="line">       <span class="keyword">byte</span>[] tempByte = <span class="keyword">new</span> <span class="keyword">byte</span>[bytes.length];</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//如果还有数据，就循环。循环判断条件</span></span><br><span class="line">       <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">           <span class="comment">//获取byteBuffer中的数据</span></span><br><span class="line">           <span class="keyword">byte</span> b = byteBuffer.get();</span><br><span class="line">           <span class="comment">//放到临时数组中</span></span><br><span class="line">           tempByte[i] = b;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//打印结果</span></span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(tempByte));<span class="comment">//java</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这上面有一个flip()方法是很重要的。意思是切换到读模式。上面已经提到缓存区是双向的，既可以往缓冲区写入数据，也可以从缓冲区读取数据。但是不能同时进行，需要切换。那么这个切换模式的本质是什么呢？</p>
<h5 id="三个重要参数"><a href="#三个重要参数" class="headerlink" title="三个重要参数"></a>三个重要参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置，默认是从第一个开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//限制，不能读取或者写入的位置索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="comment">//容量，缓冲区所包含的元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<p>那么我们以上面的例子，一句一句代码进行分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">"java"</span>;</span><br><span class="line"><span class="comment">//创建一个固定大小的buffer(返回的是HeapByteBuffer)</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>当创建一个缓冲区时，参数的值是这样的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb354b4f528e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3554dad1da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>当执行到byteBuffer.put(bytes)，当put()进入多少数据，position就会增加多少，参数就会发生变化：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35643fde0f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb3564b442e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>接下来关键一步byteBuffer.flip()，会发生如下变化：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a2d1fcac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a30e0c8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>flip()方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       limit = position;</span><br><span class="line">       position = <span class="number">0</span>;</span><br><span class="line">       mark = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>为什么要这样赋值呢？因为下面有一句循环条件判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byteBuffer.hasRemaining();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断position的索引是否小于limit。</span></span><br><span class="line">    <span class="comment">//所以可以看出limit的作用就是记录写入数据的位置，那么当读取数据时，就知道读到哪个位置</span></span><br><span class="line">	<span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是在while循环中get()读取数据，读取完之后。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35a6154ff3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35acd1a4ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>最后当position等于limit时，循环判断条件不成立，就跳出循环，读取完毕。</p>
<p>所以可以看出实质上capacity容量大小是不变的，实际上是通过控制position和limit的值来控制读写的数据。</p>
<h4 id="管道-Channel"><a href="#管道-Channel" class="headerlink" title="管道(Channel)"></a>管道(Channel)</h4><p>看一下Channel有哪些子类：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35ace1446a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>常用的Channel有这四种：</p>
<blockquote>
<p>FileChannel，读写文件中的数据。SocketChannel，通过TCP读写网络中的数据。ServerSockectChannel，监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。DatagramChannel，通过UDP读写网络中的数据。</p>
</blockquote>
<p>Channel本身并不存储数据，只是负责数据的运输。必须要和Buffer一起使用。</p>
<h5 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//获取文件输入流</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"1.txt"</span>);</span><br><span class="line">       FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">       <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">       FileChannel inputStreamChannel = inputStream.getChannel();</span><br><span class="line">       <span class="comment">//获取文件输出流</span></span><br><span class="line">       FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"2.txt"</span>));</span><br><span class="line">       <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">       FileChannel outputStreamChannel = outputStream.getChannel();</span><br><span class="line">       <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>)file.length());</span><br><span class="line">       <span class="comment">//把输入流通道的数据读取到缓冲区</span></span><br><span class="line">       inputStreamChannel.read(byteBuffer);</span><br><span class="line">       <span class="comment">//切换成读模式</span></span><br><span class="line">       byteBuffer.flip();</span><br><span class="line">       <span class="comment">//把数据从缓冲区写入到输出流通道</span></span><br><span class="line">       outputStreamChannel.write(byteBuffer);</span><br><span class="line">       <span class="comment">//关闭通道</span></span><br><span class="line">       outputStream.close();</span><br><span class="line">       inputStream.close();</span><br><span class="line">       outputStreamChannel.close();</span><br><span class="line">       inputStreamChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35cd16c41a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h5 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//获取ServerSocketChannel</span></span><br><span class="line">       ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">       InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">       <span class="comment">//绑定地址，端口号</span></span><br><span class="line">       serverSocketChannel.bind(address);</span><br><span class="line">       <span class="comment">//创建一个缓冲区</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="comment">//获取SocketChannel</span></span><br><span class="line">           SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">           <span class="keyword">while</span> (socketChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//打印结果</span></span><br><span class="line">               System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">               <span class="comment">//清空缓冲区</span></span><br><span class="line">               byteBuffer.clear();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后运行main()方法，我们可以通过telnet命令进行连接测试：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35d02b9462?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>通过上面的例子可以知道，通过ServerSocketChannel.open()方法可以获取服务器的通道，然后绑定一个地址端口号，接着accept()方法可获得一个SocketChannel通道，也就是客户端的连接通道。</p>
<p>最后配合使用Buffer进行读写即可。</p>
<p>这就是一个简单的例子，实际上上面的例子是阻塞式的。要做到非阻塞还需要使用选择器Selector。</p>
<h4 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h4><p>Selector翻译成选择器，有些人也会翻译成多路复用器，实际上指的是同一样东西。</p>
<p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p>
<p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现单线程管理多个Channel的目的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35e175a721?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h5 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h5><table>
<thead>
<tr>
<th>API方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Selector.open()</td>
<td>打开一个选择器。</td>
</tr>
<tr>
<td>select()</td>
<td>选择一组键，其相应的通道已为 I/O 操作准备就绪。</td>
</tr>
<tr>
<td>selectedKeys()</td>
<td>返回此选择器的已选择键集。</td>
</tr>
</tbody></table>
<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><h4 id="通道间的数据传输"><a href="#通道间的数据传输" class="headerlink" title="通道间的数据传输"></a>通道间的数据传输</h4><p>这里主要介绍两个通道与通道之间数据传输的方式：</p>
<p>transferTo()：把源通道的数据传输到目的通道中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//获取文件输入流</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"1.txt"</span>);</span><br><span class="line">       FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">       <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">       FileChannel inputStreamChannel = inputStream.getChannel();</span><br><span class="line">       <span class="comment">//获取文件输出流</span></span><br><span class="line">       FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"2.txt"</span>));</span><br><span class="line">       <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">       FileChannel outputStreamChannel = outputStream.getChannel();</span><br><span class="line">       <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line">       <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">       inputStreamChannel.transferTo(<span class="number">0</span>, byteBuffer.limit(), outputStreamChannel);</span><br><span class="line">       <span class="comment">//关闭通道</span></span><br><span class="line">       outputStream.close();</span><br><span class="line">       inputStream.close();</span><br><span class="line">       outputStreamChannel.close();</span><br><span class="line">       inputStreamChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>transferFrom()：把来自源通道的数据传输到目的通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//获取文件输入流</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"1.txt"</span>);</span><br><span class="line">       FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">       <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">       FileChannel inputStreamChannel = inputStream.getChannel();</span><br><span class="line">       <span class="comment">//获取文件输出流</span></span><br><span class="line">       FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"2.txt"</span>));</span><br><span class="line">       <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">       FileChannel outputStreamChannel = outputStream.getChannel();</span><br><span class="line">       <span class="comment">//创建一个byteBuffer，小文件所以就直接一次读取，不分多次循环了</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line">       <span class="comment">//把输入流通道的数据读取到输出流的通道</span></span><br><span class="line">       outputStreamChannel.transferFrom(inputStreamChannel,<span class="number">0</span>,byteBuffer.limit());</span><br><span class="line">       <span class="comment">//关闭通道</span></span><br><span class="line">       outputStream.close();</span><br><span class="line">       inputStream.close();</span><br><span class="line">       outputStreamChannel.close();</span><br><span class="line">       inputStreamChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="分散读取和聚合写入"><a href="#分散读取和聚合写入" class="headerlink" title="分散读取和聚合写入"></a>分散读取和聚合写入</h4><p>先看一下FileChannel的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span> </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出实现了GatheringByteChannel, ScatteringByteChannel接口。也就是支持分散读取和聚合写入的操作。怎么使用呢，请看以下例子：</p>
<p>我们写一个main方法来实现复制1.txt文件，文件内容是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz&#x2F;&#x2F;26个字母</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//获取文件输入流</span></span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">"1.txt"</span>);</span><br><span class="line">       FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">       <span class="comment">//从文件输入流获取通道</span></span><br><span class="line">       FileChannel inputStreamChannel = inputStream.getChannel();</span><br><span class="line">       <span class="comment">//获取文件输出流</span></span><br><span class="line">       FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"2.txt"</span>));</span><br><span class="line">       <span class="comment">//从文件输出流获取通道</span></span><br><span class="line">       FileChannel outputStreamChannel = outputStream.getChannel();</span><br><span class="line">       <span class="comment">//创建三个缓冲区，分别都是5</span></span><br><span class="line">       ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">       ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">       ByteBuffer byteBuffer3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">       <span class="comment">//创建一个缓冲区数组</span></span><br><span class="line">       ByteBuffer[] buffers = <span class="keyword">new</span> ByteBuffer[]&#123;byteBuffer1, byteBuffer2, byteBuffer3&#125;;</span><br><span class="line">       <span class="comment">//循环写入到buffers缓冲区数组中，分散读取</span></span><br><span class="line">       <span class="keyword">long</span> read;</span><br><span class="line">       <span class="keyword">long</span> sumLength = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> ((read = inputStreamChannel.read(buffers)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           sumLength += read;</span><br><span class="line">           Arrays.stream(buffers)</span><br><span class="line">                   .map(buffer -&gt; <span class="string">"posstion="</span> + buffer.position() + <span class="string">",limit="</span> + buffer.limit())</span><br><span class="line">                   .forEach(System.out::println);</span><br><span class="line">           <span class="comment">//切换模式</span></span><br><span class="line">           Arrays.stream(buffers).forEach(Buffer::flip);</span><br><span class="line">           <span class="comment">//聚合写入到文件输出通道</span></span><br><span class="line">           outputStreamChannel.write(buffers);</span><br><span class="line">           <span class="comment">//清空缓冲区</span></span><br><span class="line">           Arrays.stream(buffers).forEach(Buffer::clear);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"总长度:"</span> + sumLength);</span><br><span class="line">       <span class="comment">//关闭通道</span></span><br><span class="line">       outputStream.close();</span><br><span class="line">       inputStream.close();</span><br><span class="line">       outputStreamChannel.close();</span><br><span class="line">       inputStreamChannel.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">posstion=<span class="number">5</span>,limit=<span class="number">5</span></span><br><span class="line">posstion=<span class="number">5</span>,limit=<span class="number">5</span></span><br><span class="line">posstion=<span class="number">5</span>,limit=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">posstion=<span class="number">5</span>,limit=<span class="number">5</span></span><br><span class="line">posstion=<span class="number">5</span>,limit=<span class="number">5</span></span><br><span class="line">posstion=<span class="number">1</span>,limit=<span class="number">5</span></span><br><span class="line"></span><br><span class="line">总长度:<span class="number">26</span></span><br></pre></td></tr></table></figure>

<p>可以看到循环了两次。第一次循环时，三个缓冲区都读取了5个字节，总共读取了15，也就是读满了。还剩下11个字节，于是第二次循环时，前两个缓冲区分配了5个字节，最后一个缓冲区给他分配了1个字节，刚好读完。总共就是26个字节。</p>
<p>这就是分散读取，聚合写入的过程。</p>
<p>使用场景就是可以使用一个缓冲区数组，自动地根据需要去分配缓冲区的大小。可以减少内存消耗。网络IO也可以使用</p>
<h4 id="非直接-直接缓冲区"><a href="#非直接-直接缓冲区" class="headerlink" title="非直接/直接缓冲区"></a>非直接/直接缓冲区</h4><p>非直接缓冲区的创建方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br></pre></td></tr></table></figure>

<p>直接缓冲区的创建方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br></pre></td></tr></table></figure>

<p>非直接/直接缓冲区的区别示意图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35d1ab5ca0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35ed8239eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>从示意图中我们可以发现，最大的不同在于直接缓冲区不需要再把文件内容copy到物理内存中。这就大大地提高了性能。其实在介绍Buffer时，我们就有接触到这个概念。直接缓冲区是堆外内存，在本地文件IO效率会更高一点。</p>
<h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>其实NIO的主要用途是网络IO，在NIO之前java要使用网络编程就只有用Socket。而Socket是阻塞的，显然对于高并发的场景是不适用的。所以NIO的出现就是解决了这个痛点。</p>
<p>主要思想是把Channel通道注册到Selector中，通过Selector去监听Channel中的事件状态，这样就不需要阻塞等待客户端的连接，从主动等待客户端的连接，变成了通过事件驱动。没有监听的事件，服务器可以做自己的事情。</p>
<h4 id="使用Selector的小例子"><a href="#使用Selector的小例子" class="headerlink" title="使用Selector的小例子"></a>使用Selector的小例子</h4><p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//打开一个ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//绑定地址</span></span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//打开一个选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//serverSocketChannel注册到选择器中,监听连接事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//循环等待客户端的连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//等待3秒，（返回0相当于没有事件）如果没有事件，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">3000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"服务器等待3秒，没有连接"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有事件selector.select(3000)&gt;0的情况,获取事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//获取迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到事件</span></span><br><span class="line">                SelectionKey selectionKey = it.next();</span><br><span class="line">                <span class="comment">//判断如果是连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//服务器与客户端建立连接，获取socketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//设置成非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//把socketChannel注册到selector中，监听读事件，并绑定一个缓冲区</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//获取通道</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//获取关联的ByteBuffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line">                    <span class="comment">//打印从客户端获取到的数据</span></span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"from 客户端："</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从事件集合中删除已处理的事件，防止重复处理</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">boolean</span> connect = socketChannel.connect(address);</span><br><span class="line">        <span class="comment">//判断是否连接成功</span></span><br><span class="line">        <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">            <span class="comment">//等待连接的过程中</span></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">"连接服务器需要时间，期间可以做其他事情..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = <span class="string">"hello java"</span>;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">//把byteBuffer数据写入到通道中</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        <span class="comment">//让程序卡在这个位置，不关闭连接</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来启动服务端，然后再启动客户端，我们可以看到控制台打印以下信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器等待<span class="number">3</span>秒，没有连接</span><br><span class="line">服务器等待<span class="number">3</span>秒，没有连接</span><br><span class="line">from 客户端：hello java                       </span><br><span class="line">服务器等待<span class="number">3</span>秒，没有连接</span><br><span class="line">服务器等待<span class="number">3</span>秒，没有连接</span><br></pre></td></tr></table></figure>

<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>在SelectionKey类中有四个常量表示四种事件，来看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//2^0=1</span></span><br><span class="line">    <span class="comment">//写事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 2^2=4</span></span><br><span class="line">    <span class="comment">//连接操作,Client端支持的一种操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">// 2^3=8</span></span><br><span class="line">    <span class="comment">//连接可接受操作,仅ServerSocketChannel支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 2^4=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附加的对象(可选)，把通道注册到选择器中时可以附加一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span></span><br></pre></td></tr></table></figure>

<p>从selectionKey中获取附件对象可以使用attachment()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> attachment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>Java AIO，全程 Asynchronous IO，是异步非阻塞的IO。是一种非阻塞异步的通信模式。</p>
<p>在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p>
<p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h2 id="使用NIO实现多人聊天室"><a href="#使用NIO实现多人聊天室" class="headerlink" title="使用NIO实现多人聊天室"></a>使用NIO实现多人聊天室</h2><p>服务端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器初始化成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开一个选择器</span></span><br><span class="line">            <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//打开serverSocketChannel</span></span><br><span class="line">            <span class="keyword">this</span>.serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定地址，端口号</span></span><br><span class="line">            <span class="keyword">this</span>.serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//把通道注册到选择器中</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听，并且接受客户端消息，转发到其他客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//获取监听的事件总数</span></span><br><span class="line">                <span class="keyword">int</span> count = selector.select(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="comment">//获取SelectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = it.next();</span><br><span class="line">                        <span class="comment">//如果是获取连接事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                            <span class="comment">//设置为非阻塞</span></span><br><span class="line">                            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//注册到选择器中</span></span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">"上线了~"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果是读就绪事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//读取消息，并且转发到其他客户端</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"等待..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从selectionKey中获取channel</span></span><br><span class="line">            socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//创建一个缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="comment">//把通道的数据写入到缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> count = socketChannel.read(byteBuffer);</span><br><span class="line">            <span class="comment">//判断返回的count是否大于0，大于0表示读取到了数据</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓冲区的byte[]转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                <span class="comment">//输出该消息到控制台</span></span><br><span class="line">                System.out.println(<span class="string">"from 客户端："</span> + msg);</span><br><span class="line">                <span class="comment">//转发到其他客户端</span></span><br><span class="line">                notifyAllClient(msg, socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//打印离线的通知</span></span><br><span class="line">                System.out.println(socketChannel.getRemoteAddress() + <span class="string">"离线了..."</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                selectionKey.cancel();</span><br><span class="line">                <span class="comment">//关闭流</span></span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发消息到其他客户端</span></span><br><span class="line"><span class="comment">     * msg 消息</span></span><br><span class="line"><span class="comment">     * noNotifyChannel 不需要通知的Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyAllClient</span><span class="params">(String msg, SocketChannel noNotifyChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器转发消息~"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selector.keys()) &#123;</span><br><span class="line">            Channel channel = selectionKey.channel();</span><br><span class="line">            <span class="comment">//channel的类型实际类型是SocketChannel，并且排除不需要通知的通道</span></span><br><span class="line">            <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel != noNotifyChannel) &#123;</span><br><span class="line">                <span class="comment">//强转成SocketChannel类型</span></span><br><span class="line">                SocketChannel socketChannel = (SocketChannel) channel;</span><br><span class="line">                <span class="comment">//通过消息，包裹获取一个缓冲区</span></span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroupChatServer chatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        <span class="comment">//启动服务器，监听</span></span><br><span class="line">        chatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClinet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClinet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//打开选择器</span></span><br><span class="line">            <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">            <span class="comment">//连接服务器</span></span><br><span class="line">            socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, GroupChatServer.PORT));</span><br><span class="line">            <span class="comment">//设置为非阻塞</span></span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册到选择器中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">//获取用户名</span></span><br><span class="line">            userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(userName + <span class="string">" is ok~"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//发送消息到服务端</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        msg = userName + <span class="string">"说："</span> + msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//读取服务端发送过来的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey selectionKey = iterator.next();</span><br><span class="line">                    <span class="comment">//判断是读就绪事件</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="comment">//创建一个缓冲区</span></span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//从服务器的通道中读取数据到缓冲区</span></span><br><span class="line">                        channel.read(byteBuffer);</span><br><span class="line">                        <span class="comment">//缓冲区的数据，转成字符串，并打印</span></span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroupChatClinet chatClinet = <span class="keyword">new</span> GroupChatClinet();</span><br><span class="line">        <span class="comment">//启动线程，读取服务器转发过来的消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                chatClinet.readMsg();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//主线程发送消息到服务器</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String msg = scanner.nextLine();</span><br><span class="line">            chatClinet.sendMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动服务端的main方法，再启动两个客户端的main方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35f0eb6f29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>然后使用两个客户端开始聊天了~</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb35f32978aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172eeb362449a684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年06月27日 15:43</p>
        <p>原始链接： <a class="post-url" href="/2020/06/02/JavaNote_10/" title="JavaIO相关知识">https://guoshusong.github.io/2020/06/02/JavaNote_10/</a></p>
        <footer>
            <a href="https://guoshusong.github.io">
                <img src="/images/logo.png" alt="GuoShuSong">
                GuoShuSong
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://guoshusong.github.io/2020/06/02/JavaNote_10/&title=《JavaIO相关知识》 — gssplus's Blog&pic=https://i.loli.net/2020/06/02/kRu437CeQYzhwWv.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://guoshusong.github.io/2020/06/02/JavaNote_10/&title=《JavaIO相关知识》 — gssplus's Blog&source=同步、异步、阻塞、非阻塞、BIO、NIO、AIO" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://guoshusong.github.io/2020/06/02/JavaNote_10/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaIO相关知识》 — gssplus's Blog&url=https://guoshusong.github.io/2020/06/02/JavaNote_10/&via=https://guoshusong.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://guoshusong.github.io/2020/06/02/JavaNote_10/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://guoshusong.github.io/2020/06/02/JavaNote_10/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java基础/" class="color2">Java基础</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步、异步、阻塞、非阻塞、BIO、NIO、AIO"><span class="post-toc-text">同步、异步、阻塞、非阻塞、BIO、NIO、AIO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#IO简介"><span class="post-toc-text">IO简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-中-IO-流分为几种"><span class="post-toc-text">Java 中 IO 流分为几种?</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步与异步"><span class="post-toc-text">同步与异步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#阻塞与非阻塞"><span class="post-toc-text">阻塞与非阻塞</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BIO"><span class="post-toc-text">BIO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NIO"><span class="post-toc-text">NIO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NIO的三大核心"><span class="post-toc-text">NIO的三大核心</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缓冲区-Buffer"><span class="post-toc-text">缓冲区(Buffer)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#什么是缓冲区"><span class="post-toc-text">什么是缓冲区</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#常用的类型ByteBuffer"><span class="post-toc-text">常用的类型ByteBuffer</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#创建Buffer的方式"><span class="post-toc-text">创建Buffer的方式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#HeapByteBuffer与DirectByteBuffer的区别"><span class="post-toc-text">HeapByteBuffer与DirectByteBuffer的区别</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Buffer的初体验"><span class="post-toc-text">Buffer的初体验</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#三个重要参数"><span class="post-toc-text">三个重要参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#管道-Channel"><span class="post-toc-text">管道(Channel)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#FileChannel"><span class="post-toc-text">FileChannel</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#SocketChannel"><span class="post-toc-text">SocketChannel</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择器-Selector"><span class="post-toc-text">选择器(Selector)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#核心API"><span class="post-toc-text">核心API</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件IO"><span class="post-toc-text">文件IO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通道间的数据传输"><span class="post-toc-text">通道间的数据传输</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分散读取和聚合写入"><span class="post-toc-text">分散读取和聚合写入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#非直接-直接缓冲区"><span class="post-toc-text">非直接&#x2F;直接缓冲区</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络IO"><span class="post-toc-text">网络IO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用Selector的小例子"><span class="post-toc-text">使用Selector的小例子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#SelectionKey"><span class="post-toc-text">SelectionKey</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#AIO"><span class="post-toc-text">AIO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用NIO实现多人聊天室"><span class="post-toc-text">使用NIO实现多人聊天室</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/06/02/JavaNote_11/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Java基础知识面经
        
      </span>
    </a>
  
  
    <a href="/2020/06/02/JavaNote_09/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Java多线程-线程池</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      

      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 GuoShuSong<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://guoshusong.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Java/">Java</a><a class="category-link" href="/categories/MySQL/">MySQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/SpringBoot/">SpringBoot</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><a class="category-link" href="/categories/%E7%90%90%E7%A2%8E/">琐碎</a><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 12px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Docker/" style="font-size: 12px;">Docker</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">Java基础</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 14px;">MySQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/SpringBoot/" style="font-size: 20px;">SpringBoot</a> <a href="/tags/jvm/" style="font-size: 16px;">jvm</a> <a href="/tags/%E4%B8%B2/" style="font-size: 10px;">串</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 12px;">其他</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>