<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java集合基础 | gssplus&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="gss's Blog" />
  
  <meta name="description" content="Collection、Set、List、Map">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合基础">
<meta property="og:url" content="https://guoshusong.github.io/2020/06/02/JavaNote_05/index.html">
<meta property="og:site_name" content="gssplus&#39;s Blog">
<meta property="og:description" content="Collection、Set、List、Map">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/11/18/16e7e915afd4201c?w=1383&h=638&f=png&s=85707">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/11/18/16e7ebe4cc3f1e86?w=739&h=390&f=png&s=101271">
<meta property="og:image" content="https://i.loli.net/2020/02/28/5wnr1j2DeOkiIqF.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/11/18/16e7eb3674785cc6?w=1224&h=491&f=png&s=99145">
<meta property="og:image" content="https://i.loli.net/2020/02/28/pVKsQjPDy3A81LJ.jpg">
<meta property="article:published_time" content="2020-06-02T06:08:50.491Z">
<meta property="article:modified_time" content="2020-06-02T08:12:27.850Z">
<meta property="article:author" content="GuoShuSong">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/11/18/16e7e915afd4201c?w=1383&h=638&f=png&s=85707">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Hello,Here is gssplus!</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Hello,Here is gssplus!
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        我见过春日夏风，秋月冬雪，也曾踏遍南水北山，东麓西岭，可这四季春秋，苍山央水，都不及你瞅我展眉一笑
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="MinHow" target="_blank" href="//guoshusong.github.io/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/guoshusong">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-JavaNote_05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Java集合基础
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Java/">Java</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-06-02
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="Collection、Set、List、Map"><a href="#Collection、Set、List、Map" class="headerlink" title="Collection、Set、List、Map"></a>Collection、Set、List、Map</h2><a id="more"></a>

<h3 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h3><p>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p>
<ul>
<li>Collection：代表一组对象，每一个对象都是它的子元素。</li>
<li>Set：不包含重复元素的 Collection。</li>
<li>List：有顺序的 collection，并且可以包含重复元素。</li>
<li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li>
<li>还有其它接口 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator。</li>
</ul>
<h3 id="为什么集合类没有实现Cloneable和Serializable接口？"><a href="#为什么集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="为什么集合类没有实现Cloneable和Serializable接口？"></a>为什么集合类没有实现Cloneable和Serializable接口？</h3><p>克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化</p>
<p>对于具体的实现类, java.util.ArrayList,LinkedList,HashMap,HashSet, 有什么特性就实现什么接口，可以实现多个接口即可。实际这些类都实现了Cloneable和Serializable接口，因为实际应用中集合类很常用，串行化和克隆也常用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h3><p>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。</p>
<p>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h3 id="Iterator和ListIterator的区别是什么？"><a href="#Iterator和ListIterator的区别是什么？" class="headerlink" title="Iterator和ListIterator的区别是什么？"></a>Iterator和ListIterator的区别是什么？</h3><ul>
<li><p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List 。</p>
</li>
<li><p>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</p>
</li>
<li><p>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
</li>
</ul>
<h3 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><p><a href="https://www.jianshu.com/p/1c73ea87c67d" target="_blank" rel="noopener">关于快速失败和安全失败的概念</a></p>
<p>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>
<p>java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
<h3 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h3><h4 id="HashMap的结构（jdk1-8）"><a href="#HashMap的结构（jdk1-8）" class="headerlink" title="HashMap的结构（jdk1.8）"></a>HashMap的结构（jdk1.8）</h4><p>HashMap（数组+链表+红黑树）的结构，利用了红黑树，所以其由 数组+链表+红黑<br>树组成：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/18/16e7e915afd4201c?w=1383&h=638&f=png&s=85707" alt=""><br>HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个蓝色的实体是嵌套类Node(在Java7叫Entry,在Java8中叫Node)的实例，Node包含四个属性： key, value, hash 值和用于单向链表的 next。</p>
<h4 id="Java-中的-HashMap"><a href="#Java-中的-HashMap" class="headerlink" title="Java 中的 HashMap"></a>Java 中的 HashMap</h4><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快<br>的访问速度，但遍历顺序却是不确定的。  </p>
<p>HashMap 最多只允许一条记录的键为 null，允许多条记<br>录的值为 null。   </p>
<p>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导<br>致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使<br>HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p>
<h4 id="HashMap重要参数"><a href="#HashMap重要参数" class="headerlink" title="HashMap重要参数"></a>HashMap重要参数</h4><ol>
<li>capacity：当前数组容量16 ，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li>
<li>loadFactor：负载因子，默认为 0.75</li>
<li>threshold：扩容的阈值，等于 capacity * loadFactor</li>
</ol>
<table><tr><td bgcolor=gray>
数组大小为什么是2的幂次方?

<p>这样是为了位运算的方便，位与运算比算数计算的效率高了很多是为了服务将Key映射到index的算法。所有的key我们都会拿到他的hash，但是我们怎么尽可能的得到一个均匀分布的hash呢？</p>
<p>我们通过Key的HashCode值去做位运算。</p>
<p>Hash的公式—&gt; index = HashCode（Key） &amp; （Length - 1）</p>
<p>15的的二进制是1111，那10111011000010110100 &amp;1111 十进制就是4</p>
<p>因为在使用是2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。</p>
<p>只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>
<p>这是为了实现均匀分布。</p>
</td>
</tr>
</table>

<h4 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h4><p><a href="https://blog.csdn.net/HNUST_LIZEMING/article/details/89334204" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="HashMap查询"><a href="#HashMap查询" class="headerlink" title="HashMap查询"></a>HashMap查询</h4><p>查找的时候，根据 hash 值我们能够快速定位到数组的<br>具体下标，但是之后的话， 需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 </p>
<p>为了降低这部分的开销，在 Java8 中， 当链表中的元素超过了 8 个以后，<br>会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<h4 id="hashCode-和-equals-方法的重要性体现在什么地方？"><a href="#hashCode-和-equals-方法的重要性体现在什么地方？" class="headerlink" title="hashCode() 和 equals() 方法的重要性体现在什么地方？"></a>hashCode() 和 equals() 方法的重要性体现在什么地方？</h4><p>Java 中的 HashMap 使用 hashCode() 和 equals() 方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的 hash 值。</p>
<p>因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对 HashMap 的精确性和正确性是至关重要的。</p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>哈希表（HashTable）又叫做散列表，根它通过把key映射到表中一个位置来访问记录，以加快查找速度。这个映射函数就叫做散列（哈希）函数，存放记录的数组叫做散列表。</p>
<p>哈希表是一个时间和空间上平衡的例子。如果没有空间的限制，我们可以直接用键来作为数组的索引，这样可以将查找时间做到最快（O(1)）。如果没有时间的限制，我们可以使用无序链表进行顺序查找，这样只需要很少的内存</p>
<h3 id="为什么Hashtable的速度快？"><a href="#为什么Hashtable的速度快？" class="headerlink" title="为什么Hashtable的速度快？"></a>为什么Hashtable的速度快？</h3><p>Hashtable是由数组与链表。数组的特点就是查找容易，插入删除困难；而链表的特点就是查找困难，但是插入删除容易。既然两者各有优缺点，那么Hashtable查找容易，插入删除也会快起来。</p>
<h3 id="Hashtable如何根据key查找？"><a href="#Hashtable如何根据key查找？" class="headerlink" title="Hashtable如何根据key查找？"></a>Hashtable如何根据key查找？</h3><p>使用哈希函数将被查找的key转化为数组的索引。在理想的状态下，不同的键会被转化成不同的索引值。但是那是理想状态，我们实践当中是不可能一直是理想状态的。当不同的键生成了相同的索引的时候，即是哈希冲突，处理冲突方式：</p>
<ul>
<li>拉链法</li>
<li>线性探索法</li>
</ul>
<h4 id="LinkHashMap"><a href="#LinkHashMap" class="headerlink" title="LinkHashMap"></a>LinkHashMap</h4><p>LinkHashMap=HashMap + LinkedList</p>
<p>LinkedHashMap 是基于 HashMap 实现的一种集合，具有 HashMap 集合上面所说的所有特点，除了 HashMap 无序的特点，LinkedHashMap 是有序的，因为 LinkedHashMap 在 HashMap 的基础上单独维护了一个具有所有数据的双向链表，该链表保证了元素迭代的顺序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/18/16e7ebe4cc3f1e86?w=739&h=390&f=png&s=101271" alt=""></p>
<ul>
<li>LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。</li>
<li>HashMap无序；LinkedHashMap有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</li>
<li>LinkedHashMap存取数据，还是跟HashMap一样使用的Entry[]的方式，双向链表只是为了保证顺序。</li>
<li>LinkedHashMap是线程不安全的</li>
</ul>
<p><img src="https://i.loli.net/2020/02/28/5wnr1j2DeOkiIqF.png" alt="HashMap常见面试题.PNG"></p>
<h3 id="三、ArrayList、-Vector-和-LinkedList"><a href="#三、ArrayList、-Vector-和-LinkedList" class="headerlink" title="三、ArrayList、 Vector 和 LinkedList"></a>三、ArrayList、 Vector 和 LinkedList</h3><h4 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h4><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。</p>
<p>数组的缺点是每个元素之间不能有间隔， 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。 </p>
<p>当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进<br>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p>
<p>ArrayList支持序列化功能，支持克隆（浅拷贝）功能，排序功能等</p>
<h4 id="ArrayList-是如何扩容的？"><a href="#ArrayList-是如何扩容的？" class="headerlink" title="ArrayList 是如何扩容的？"></a>ArrayList 是如何扩容的？</h4><p>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。<strong>每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容</strong>。  </p>
<p><strong>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍</strong></p>
<h4 id="ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><a href="#ArrayList-集合加入-1-万条数据，应该怎么提高效率？" class="headerlink" title="ArrayList 集合加入 1 万条数据，应该怎么提高效率？"></a>ArrayList 集合加入 1 万条数据，应该怎么提高效率？</h4><p>ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！</p>
<h4 id="Vector（数组实现、-线程同步）"><a href="#Vector（数组实现、-线程同步）" class="headerlink" title="Vector（数组实现、 线程同步）"></a>Vector（数组实现、 线程同步）</h4><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此,访问它比访问 ArrayList 慢。</p>
<h4 id="LinkList（链表）"><a href="#LinkList（链表）" class="headerlink" title="LinkList（链表）"></a>LinkList（链表）</h4><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆<br>栈、队列和双向队列使用</p>
<h3 id="HashSet、TreeSet以及LinkHashSet"><a href="#HashSet、TreeSet以及LinkHashSet" class="headerlink" title="HashSet、TreeSet以及LinkHashSet"></a>HashSet、TreeSet以及LinkHashSet</h3><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素， 值不能重复。</p>
<p>对象的相等性本质是对象 hashCode 值（ java 是依据对象的内存地址计算出的此序号） 判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p>
<p>HashSet 通过 hashCode 值来确定元素在内存中的位置。 一个 hashCode 位置上可以存放多个元素。</p>
<p>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。 如图 1 表示 hashCode 值不相同的情况； 图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/18/16e7eb3674785cc6?w=1224&h=491&f=png&s=99145" alt=""></p>
<h4 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h4><ol>
<li>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数</li>
</ol>
<h4 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h4><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同.</p>
<p>因此 LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<h3 id="集合的区别"><a href="#集合的区别" class="headerlink" title="集合的区别"></a>集合的区别</h3><h4 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h4><p>HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。但是，他们有以下不同点： HashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。</p>
<p>Hashtable 是同步的，而 HashMap 不是。因此， HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。</p>
<p>HashMap 提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面，Hashtable 提供了对键的列举(Enumeration)。</p>
<p>一般认为 Hashtable 是一个遗留的类。</p>
<h4 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h4><p>下面列出了 Array 和 ArrayList 的不同点：</p>
<p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p>
<p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p>
<p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h4 id="ArrayList-和-LinkedList-有什么区别？"><a href="#ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="ArrayList 和 LinkedList 有什么区别？"></a>ArrayList 和 LinkedList 有什么区别？</h4><p>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：</p>
<p>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</p>
<p>相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p>
<p>LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h4 id="Comparable-和Comparator-接口是干什么的？列出它们的区别。"><a href="#Comparable-和Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable 和Comparator 接口是干什么的？列出它们的区别。"></a>Comparable 和Comparator 接口是干什么的？列出它们的区别。</h4><p>Java 提供了只包含一个 compareTo() 方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p>
<p>Java 提供了包含 compare() 和 equals() 两个方法的 Comparator 接口。compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals() 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回 true。</p>
<h4 id="HashSet-和-TreeSet-有什么区别？"><a href="#HashSet-和-TreeSet-有什么区别？" class="headerlink" title="HashSet 和 TreeSet 有什么区别？"></a>HashSet 和 TreeSet 有什么区别？</h4><p>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是 O(1)。</p>
<p>另一方面，TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains() 方法的时间复杂度是 O(logn)。</p>
<h4 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h4><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<ol>
<li><p>ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。</p>
</li>
<li><p>HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许</p>
</li>
</ol>
<blockquote>
<p>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。</p>
</blockquote>
<h4 id="List、Set、Map-是否继承自-Collection-接口？"><a href="#List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="List、Set、Map 是否继承自 Collection 接口？"></a>List、Set、Map 是否继承自 Collection 接口？</h4><p>List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h4 id="说出-ArrayList、Vector、LinkedList-的存储性能和特性？"><a href="#说出-ArrayList、Vector、LinkedList-的存储性能和特性？" class="headerlink" title="说出 ArrayList、Vector、LinkedList 的存储性能和特性？"></a>说出 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引娶元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差。</p>
<p>而 LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，其实对内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>Vector 属于遗留容器（早期的 JDK 中使用的容器，除此之外 Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），现在已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果需要多个线程操作同一个容器，那么可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这其实是装潢模式最好的例子，将已有对象传入另一个类的构造器中创建新的对象来增加新功能）。</p>
<h4 id="List、Map、Set-三个接口存储元素时各有什么特点？"><a href="#List、Map、Set-三个接口存储元素时各有什么特点？" class="headerlink" title="List、Map、Set 三个接口存储元素时各有什么特点？"></a>List、Map、Set 三个接口存储元素时各有什么特点？</h4><ul>
<li>List 是有序的 Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，这类似于 Java 的数组。</li>
<li>Set 是一种不包含重复的元素的 Collection，即任意的两个元素 e1 和 e2 都有e1.equals(e2)=false，Set 最多有一个 null 元素。</li>
<li>Map 接口 ：请注意，Map 没有继承 Collection 接口，Map 提供 key 到 value 的映射</li>
</ul>
<p><img src="https://i.loli.net/2020/02/28/pVKsQjPDy3A81LJ.jpg" alt="集合总结1.jpg"></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年06月02日 16:12</p>
        <p>原始链接： <a class="post-url" href="/2020/06/02/JavaNote_05/" title="Java集合基础">https://guoshusong.github.io/2020/06/02/JavaNote_05/</a></p>
        <footer>
            <a href="https://guoshusong.github.io">
                <img src="/images/logo.png" alt="GuoShuSong">
                GuoShuSong
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://guoshusong.github.io/2020/06/02/JavaNote_05/&title=《Java集合基础》 — gssplus's Blog&pic=https://i.loli.net/2020/06/02/kRu437CeQYzhwWv.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://guoshusong.github.io/2020/06/02/JavaNote_05/&title=《Java集合基础》 — gssplus's Blog&source=Collection、Set、List、Map" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://guoshusong.github.io/2020/06/02/JavaNote_05/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java集合基础》 — gssplus's Blog&url=https://guoshusong.github.io/2020/06/02/JavaNote_05/&via=https://guoshusong.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://guoshusong.github.io/2020/06/02/JavaNote_05/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://guoshusong.github.io/2020/06/02/JavaNote_05/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java基础/" class="color2">Java基础</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection、Set、List、Map"><span class="post-toc-text">Collection、Set、List、Map</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java集合类框架的基本接口有哪些？"><span class="post-toc-text">Java集合类框架的基本接口有哪些？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么集合类没有实现Cloneable和Serializable接口？"><span class="post-toc-text">为什么集合类没有实现Cloneable和Serializable接口？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Collection-和-Collections-的区别？"><span class="post-toc-text">Collection 和 Collections 的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Iterator和ListIterator的区别是什么？"><span class="post-toc-text">Iterator和ListIterator的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><span class="post-toc-text">快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap、Hashtable"><span class="post-toc-text">HashMap、Hashtable</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap的结构（jdk1-8）"><span class="post-toc-text">HashMap的结构（jdk1.8）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java-中的-HashMap"><span class="post-toc-text">Java 中的 HashMap</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap重要参数"><span class="post-toc-text">HashMap重要参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#头插法和尾插法"><span class="post-toc-text">头插法和尾插法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap查询"><span class="post-toc-text">HashMap查询</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#hashCode-和-equals-方法的重要性体现在什么地方？"><span class="post-toc-text">hashCode() 和 equals() 方法的重要性体现在什么地方？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Hashtable"><span class="post-toc-text">Hashtable</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么Hashtable的速度快？"><span class="post-toc-text">为什么Hashtable的速度快？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Hashtable如何根据key查找？"><span class="post-toc-text">Hashtable如何根据key查找？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#LinkHashMap"><span class="post-toc-text">LinkHashMap</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、ArrayList、-Vector-和-LinkedList"><span class="post-toc-text">三、ArrayList、 Vector 和 LinkedList</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList（数组）"><span class="post-toc-text">ArrayList（数组）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList-是如何扩容的？"><span class="post-toc-text">ArrayList 是如何扩容的？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><span class="post-toc-text">ArrayList 集合加入 1 万条数据，应该怎么提高效率？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Vector（数组实现、-线程同步）"><span class="post-toc-text">Vector（数组实现、 线程同步）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#LinkList（链表）"><span class="post-toc-text">LinkList（链表）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashSet、TreeSet以及LinkHashSet"><span class="post-toc-text">HashSet、TreeSet以及LinkHashSet</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashSet"><span class="post-toc-text">HashSet</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#TreeSet（二叉树）"><span class="post-toc-text">TreeSet（二叉树）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#LinkHashSet（HashSet-LinkedHashMap）"><span class="post-toc-text">LinkHashSet（HashSet+LinkedHashMap）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#集合的区别"><span class="post-toc-text">集合的区别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap-和-Hashtable-有什么区别？"><span class="post-toc-text">HashMap 和 Hashtable 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><span class="post-toc-text">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList-和-LinkedList-有什么区别？"><span class="post-toc-text">ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Comparable-和Comparator-接口是干什么的？列出它们的区别。"><span class="post-toc-text">Comparable 和Comparator 接口是干什么的？列出它们的区别。</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashSet-和-TreeSet-有什么区别？"><span class="post-toc-text">HashSet 和 TreeSet 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap-和-ConcurrentHashMap-的区别？"><span class="post-toc-text">HashMap 和 ConcurrentHashMap 的区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#List、Set、Map-是否继承自-Collection-接口？"><span class="post-toc-text">List、Set、Map 是否继承自 Collection 接口？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#说出-ArrayList、Vector、LinkedList-的存储性能和特性？"><span class="post-toc-text">说出 ArrayList、Vector、LinkedList 的存储性能和特性？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#List、Map、Set-三个接口存储元素时各有什么特点？"><span class="post-toc-text">List、Map、Set 三个接口存储元素时各有什么特点？</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/06/02/JavaNote_06/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          HashMap源码解析
        
      </span>
    </a>
  
  
    <a href="/2020/06/02/JavaNote_04/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Java的反射机制</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      

      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 GuoShuSong<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://guoshusong.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Java/">Java</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><a class="category-link" href="/categories/%E7%90%90%E7%A2%8E/">琐碎</a><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Docker/" style="font-size: 12.5px;">Docker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Java基础</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 12.5px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">数据结构与算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Docker/" style="font-size: 12.5px;">Docker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">Java基础</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Mysql/" style="font-size: 12.5px;">Mysql</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">数据结构与算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">查找算法</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" style="font-size: 10px;">线性表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>